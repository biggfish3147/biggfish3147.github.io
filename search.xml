<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Json基础</title>
    <url>/2020/05/20/Json%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>JSON其实就是一种数据的表示格式，由于其自身的优点（XML衬托）而广泛用于前后端的<strong>文本数据交互</strong>。这里又大概能够窥见XML与JSON的暗流涌动，一如前述JSP的落寞，但不至于那么惨烈。目前XML格式的文件还广泛作为配置文件的格式存在，尽管<code>.yml</code>、<code>.properties</code>、<code>.json</code>文件也在某些地方作为配置文件的格式。</p>
<p>细想起来，无非也就是一种数据格式。编程圈里可能有很多“取代”这一说法，我并不十分认同，每种技术点自然有其存在的环境与背景，适时的发挥作用罢了。但技术的向前发展进步，是毋庸置疑的，所以我也不会无聊地选择用XML来做文本数据传输。突然想到，HTML的标签语法，是不是也存在着标签增加网络传输流量这一说法？又或者从JSON的命名看，是否前端巨头JavaScript就捧红了JSON呢？当然这是无端的幻想，技术时时刻刻都在迭代，我们唯有跟着大浪而已。</p>
<p><img src="https://cdn.jsdelivr.net/gh/biggfish3147/pics/blog/ilF1015.jpg" alt="地平线的余晖"></p>
<h1 id="Json简介"><a href="#Json简介" class="headerlink" title="Json简介"></a>Json简介</h1><p>JSON 是<strong>存储和交换文本信息</strong>的语法。类似 XML。JSON 比 XML 更小、更快，更易解析。</p>
<ul>
<li>JSON 指的是 JavaScript 对象表示法<code>JavaScript Object Notation</code></li>
<li>JSON 是<strong>轻量级的文本数据交换格式</strong></li>
<li>JSON 独立于语言</li>
<li>JSON 具有自我描述性，更易理解</li>
</ul>
<p>JSON 使用 <strong>JavaScript 语法</strong>来描述数据对象，但是 JSON 仍然独立于语言和平台。<strong>JSON 解析器和 JSON 库</strong>支持许多不同的编程语言（PHP、Java、Python中均可以使用JSON）。</p>
<p>JSON 文本格式在语法上与创建 JavaScript 对象的代码相同。由于这种相似性，无需解析器，JavaScript 程序能够使用<strong>内建的 eval() 函数</strong>，用 JSON 数据来生成原生的 JavaScript 对象。</p>
<p>注：JSON常用于<strong>前后端的数据交互</strong>（前端Ajax上传JSON数据，服务器返回JSON字符串），需要明确是<strong>文本数据</strong>，类似图片文件等不能通过JSON来传输。</p>
<h1 id="Json数据"><a href="#Json数据" class="headerlink" title="Json数据"></a>Json数据</h1><p>通过Js语法声明并初始化JSON对象，可以是单个JSON对象，也可以是JSON数组。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> JSONObject= &#123;</span><br><span class="line">    <span class="string">"name"</span>:<span class="string">"Bill Gates"</span>,</span><br><span class="line">    <span class="string">"street"</span>:<span class="string">"Fifth Avenue New York 666"</span>,</span><br><span class="line">    <span class="string">"age"</span>:<span class="number">56</span>,</span><br><span class="line">    <span class="string">"phone"</span>:<span class="string">"555 1234567"</span>&#125;;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//json数组，每个元素是一个对象    </span></span><br><span class="line"><span class="keyword">var</span> employees = [</span><br><span class="line">    &#123; <span class="string">"firstName"</span>:<span class="string">"Bill"</span> , <span class="string">"lastName"</span>:<span class="string">"Gates"</span> &#125;,</span><br><span class="line">    &#123; <span class="string">"firstName"</span>:<span class="string">"George"</span> , <span class="string">"lastName"</span>:<span class="string">"Bush"</span> &#125;,</span><br><span class="line">    &#123; <span class="string">"firstName"</span>:<span class="string">"Thomas"</span> , <span class="string">"lastName"</span>: <span class="string">"Carter"</span> &#125;</span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><ul>
<li>数据在名称/值对中（<strong>双引号</strong>）</li>
<li>数据由<strong>逗号</strong>分隔</li>
<li>花括号保存对象</li>
<li>方括号保存数组</li>
</ul>
<h2 id="Json数据值"><a href="#Json数据值" class="headerlink" title="Json数据值"></a>Json数据值</h2><ul>
<li>数字（整数或浮点数）</li>
<li>字符串（在双引号中）</li>
<li>逻辑值（true 或 false）</li>
<li>数组（在方括号中）</li>
<li>对象（在花括号中）</li>
<li>null</li>
</ul>
<blockquote>
<p>注: Js的数据类型一般为6种，其中基本数据类型：字符串（String）、数字(Number)、布尔(Boolean)、空（Null）、未定义（Undefined），引用数据类型：对象(Object)，ES6中新增Symbol（独一无二的值）。可以通过 typeof 查看变量类型，数组(Array)返回object类型，函数(Function)返回function类型。</p>
</blockquote>
<h1 id="Json基本用法"><a href="#Json基本用法" class="headerlink" title="Json基本用法"></a>Json基本用法</h1><h2 id="把-JSON-文本转换为-JavaScript-对象"><a href="#把-JSON-文本转换为-JavaScript-对象" class="headerlink" title="把 JSON 文本转换为 JavaScript 对象"></a>把 JSON 文本转换为 JavaScript 对象</h2><p>JSON 最常见的用法之一，是<strong>从 web 服务器上读取 JSON 数据（作为文件或作为 HttpRequest），将 JSON 数据转换为 JavaScript 对象</strong>，然后在网页中使用该数据。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>通过 JSON 字符串来创建对象<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">First Name: <span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">"fname"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span> <span class="comment">&lt;!--显示Bill--&gt;</span></span><br><span class="line">Last Name: <span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">"lname"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span> <span class="comment">&lt;!--显示Gates--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="actionscript"><span class="keyword">var</span> txt = <span class="string">'&#123;"employees":['</span> +</span></span><br><span class="line"><span class="actionscript"><span class="string">'&#123;"firstName":"Bill","lastName":"Gates" &#125;,'</span> +</span></span><br><span class="line"><span class="actionscript"><span class="string">'&#123;"firstName":"George","lastName":"Bush" &#125;,'</span> +</span></span><br><span class="line"><span class="actionscript"><span class="string">'&#123;"firstName":"Thomas","lastName":"Carter" &#125;]&#125;'</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> obj = <span class="built_in">eval</span> (<span class="string">"("</span> + txt + <span class="string">")"</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.getElementById(<span class="string">"fname"</span>).innerHTML=obj.employees[<span class="number">1</span>].firstName </span></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.getElementById(<span class="string">"lname"</span>).innerHTML=obj.employees[<span class="number">1</span>].lastName </span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="JSON解析器"><a href="#JSON解析器" class="headerlink" title="JSON解析器"></a>JSON解析器</h2><p>eval() 函数可编译并执行任何 JavaScript 代码。  </p>
<p>使用 JSON 解析器将 JSON 转换为 JavaScript 对象是更安全的做法。<strong>JSON 解析器只能识别 JSON 文本，而不会编译脚本</strong>。</p>
<p>在浏览器中，这提供了原生的 JSON 支持，而且 JSON 解析器的速度更快。</p>
<p><img src="https://cdn.jsdelivr.net/gh/biggfish3147/pics/blog/ilF1020.jpg" alt="行走在街头"></p>
<h1 id="Json应用示例"><a href="#Json应用示例" class="headerlink" title="Json应用示例"></a>Json应用示例</h1><p>从<strong>前端的视角</strong>来解读JSON用法，包括如何将服务端的JSON字符串解析为JSON对象，以及如何将JSON对象转换为JSON字符串传递给服务端。</p>
<h2 id="JSON-parse"><a href="#JSON-parse" class="headerlink" title="JSON.parse()"></a>JSON.parse()</h2><p>JSON 通常用于与服务端交换数据。前端接收服务器数据时一般是获得字符串。</p>
<p>我们可以使用 JSON.parse() 方法将JSON字符串数据转换为 JavaScript 对象。</p>
<p><strong>语法：JSON.parse(text, [reviver])</strong></p>
<p>reviver:&emsp;一个转换结果的函数， 将为对象的每个成员调用此函数。</p>
<ul>
<li>从服务端接收json数据</li>
<li>从服务端接收数组的json数据</li>
<li>解析日期</li>
<li>解析函数（将函数作为字符串存储，<strong>不建议在json中使用函数</strong>）</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>菜鸟教程(runoob.com)<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>字符串转换为 Date 对象<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"demo"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript"><span class="comment">//案例：可选参数reviver的使用（一般为函数）</span></span></span><br><span class="line"></span><br><span class="line"><span class="actionscript"><span class="keyword">var</span> text = <span class="string">'&#123; "name":"Runoob", "initDate":"2013-12-14", "site":"www.runoob.com"&#125;'</span>;</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> obj = <span class="built_in">JSON</span>.parse(text, <span class="function"><span class="keyword">function</span> (<span class="params">key, value</span>) </span>&#123;</span></span><br><span class="line"><span class="actionscript">	<span class="keyword">if</span> (key == <span class="string">"initDate"</span>) &#123;</span></span><br><span class="line"><span class="javascript">	    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>(value);</span></span><br><span class="line"><span class="actionscript">	&#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="actionscript">	    <span class="keyword">return</span> value;</span></span><br><span class="line">&#125;&#125;);</span><br><span class="line"></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.getElementById(<span class="string">"demo"</span>).innerHTML = obj.name + <span class="string">"创建日期："</span> + obj.initDate;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="JSON-stringify"><a href="#JSON-stringify" class="headerlink" title="JSON.stringify()"></a>JSON.stringify()</h2><p>JSON 通常用于与服务端交换数据。在<strong>向服务器发送数据时一般是字符串</strong>。</p>
<p>我们可以使用 JSON.stringify() 方法将 JavaScript 对象转换为字符串。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>菜鸟教程(runoob.com)<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>将 JavaScript 对象转换为 JSON 字符串<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"demo"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript"><span class="keyword">var</span> obj = &#123; <span class="string">"name"</span>:<span class="string">"runoob"</span>, <span class="string">"alexa"</span>:<span class="number">10000</span>, <span class="string">"site"</span>:<span class="string">"www.runoob.com"</span>&#125;;</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> myJSON = <span class="built_in">JSON</span>.stringify(obj);</span></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.getElementById(<span class="string">"demo"</span>).innerHTML = myJSON;</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript"><span class="comment">//上述两句替换后测试</span></span></span><br><span class="line"><span class="actionscript"><span class="comment">//document.getElementById("demo").innerHTML = obj;</span></span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="Java中使用JSON"><a href="#Java中使用JSON" class="headerlink" title="Java中使用JSON"></a>Java中使用JSON</h1><p>Java中并没有内置JSON的解析，因此使用JSON需要借助第三方类库。常用的如Gson、FastJson、Jackson。</p>
<p>编码：从Java变量到JSON格式的编码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//以FastJson为例</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testJson</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    JSONObject object = <span class="keyword">new</span> JSONObject();</span><br><span class="line">    <span class="comment">//string</span></span><br><span class="line">    object.put(<span class="string">"string"</span>,<span class="string">"string"</span>);</span><br><span class="line">    <span class="comment">//int</span></span><br><span class="line">    object.put(<span class="string">"int"</span>,<span class="number">2</span>);</span><br><span class="line">    <span class="comment">//boolean</span></span><br><span class="line">    object.put(<span class="string">"boolean"</span>,<span class="keyword">true</span>);</span><br><span class="line">    <span class="comment">//array</span></span><br><span class="line">    List&lt;Integer&gt; integers = Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">    object.put(<span class="string">"list"</span>,integers);</span><br><span class="line">    <span class="comment">//null</span></span><br><span class="line">    object.put(<span class="string">"null"</span>,<span class="keyword">null</span>);</span><br><span class="line">​</span><br><span class="line">    System.out.println(object);</span><br><span class="line">    <span class="comment">//&#123;"boolean":true,"string":"string","list":[1,2,3],"int":2&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解码：从 JSON 对象到 Java 变量的解码过程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testJson2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">​</span><br><span class="line">  JSONObject object = JSONObject</span><br><span class="line">      .parseObject(<span class="string">"&#123;\"boolean\":true,\"string\":\"string\",\"list\":[1,2,3],\"int\":2&#125;"</span>);</span><br><span class="line">  <span class="comment">//string</span></span><br><span class="line">  String s = object.getString(<span class="string">"string"</span>);</span><br><span class="line">  System.out.println(s);</span><br><span class="line">  <span class="comment">//int</span></span><br><span class="line">  <span class="keyword">int</span> i = object.getIntValue(<span class="string">"int"</span>);</span><br><span class="line">  System.out.println(i);</span><br><span class="line">  <span class="comment">//boolean</span></span><br><span class="line">  <span class="keyword">boolean</span> b = object.getBooleanValue(<span class="string">"boolean"</span>);</span><br><span class="line">  System.out.println(b);</span><br><span class="line">  <span class="comment">//list</span></span><br><span class="line">  List&lt;Integer&gt; integers = JSON.parseArray(object.getJSONArray(<span class="string">"list"</span>).toJSONString(),Integer.class);</span><br><span class="line">  integers.forEach(System.out::println);</span><br><span class="line">  <span class="comment">//null</span></span><br><span class="line">  System.out.println(object.getString(<span class="string">"null"</span>));</span><br><span class="line">​   </span><br><span class="line">  <span class="comment">//输出</span></span><br><span class="line">  <span class="comment">//string</span></span><br><span class="line">  <span class="comment">//2</span></span><br><span class="line">  <span class="comment">//true</span></span><br><span class="line">  <span class="comment">// 1</span></span><br><span class="line">  <span class="comment">// 2</span></span><br><span class="line">  <span class="comment">// 3</span></span><br><span class="line">  <span class="comment">// null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JSON对象与字符串的相互转化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//从字符串解析JSON对象</span></span><br><span class="line">JSONObject obj = JSON.parseObject(<span class="string">"&#123;\"runoob\":\"菜鸟教程\"&#125;"</span>);</span><br><span class="line"><span class="comment">//从字符串解析JSON数组</span></span><br><span class="line">JSONArray arr = JSON.parseArray(<span class="string">"[\"菜鸟教程\",\"RUNOOB\"]\n"</span>);</span><br><span class="line"><span class="comment">//将JSON对象转化为字符串</span></span><br><span class="line">String objStr = JSON.toJSONString(obj);</span><br><span class="line"><span class="comment">//将JSON数组转化为字符串</span></span><br><span class="line">String arrStr = JSON.toJSONString(arr);</span><br></pre></td></tr></table></figure>

<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.runoob.com/json/json-tutorial.html" target="_blank" rel="noopener">菜鸟：JSON教程</a></p>
<p><img src="https://cdn.jsdelivr.net/gh/biggfish3147/pics/blog/ilR0003.jpg" alt="平凡的一天"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Json</tag>
        <tag>数据传输</tag>
        <tag>概念</tag>
      </tags>
  </entry>
  <entry>
    <title>博客伊始</title>
    <url>/2019/09/20/%E5%8D%9A%E5%AE%A2%E4%BC%8A%E5%A7%8B/</url>
    <content><![CDATA[<h2 id="博客伊始"><a href="#博客伊始" class="headerlink" title="博客伊始"></a>博客伊始</h2><p align="right"><font color="grey">作者：冬结</font></p>

<blockquote>
<p>写在前面：<br>偶然看到Hexo模板的博客，观感不错，加上前辈也搭过，就试试以这种相对简单的形式搭建起来玩。一方面简单学习以现有框架搭建专属博客的“技术”，另一方面也能有个容器装一点自己的笔记，尽管可能比较少，可能并不安全，聊胜于无。</p>
</blockquote>
<h3 id="兴趣"><a href="#兴趣" class="headerlink" title="兴趣"></a>兴趣</h3><p>我的兴趣，很难讲。佛系（可能）心态的人在平静生活中貌似对所有的事不放心上，所以，电影可以不看、单车可以不骑、乒乓球可以不打、书可以不阅读、随笔可以不写、游戏可以不玩。自我认知是一个漫长的过程，从浪漫理想主义到实用现实主义，说到底也划不清界限。妥协的做法是就此作罢，不去深究，也就能将困惑搁置一旁。况且说辞也是一大把，比如复杂的个体就能说服我自己。一贯的自我否定，也可以说深究一法至少能够审视自我更加全面深刻，更加接近真实。否定之否定，打住！</p>
<p>接着说兴趣。从某种维度上讲，兴趣带来愉悦、专注与充实感。</p>
<p>这样说来，好的电影是我的兴趣，带给我专注与思考。看过的电影也不少，影评却没尝试过一篇。电影没有带给我充实感，但我并不认为它在浪费时间。娱乐的底质，依旧能够容纳艺术与生活。尽管总能从这种媒介中看到不真实，生活的经验依然鲜活。现在的我能以相对包容的眼光对待现实的种种“怪象”，大抵与之有所关联。</p>
<p>骑单车溜达也算得上。单车是真的单车，单人单骑，随便找个目标，也就慢慢悠悠的去。骑行就不能描述我的方式了，老老实实地去骑单车溜达。某次，什么背景的现在全无记忆，只是感到沉闷的低落，简直到不能忍受的地步，然后就溜达着去后海那边。也许逛胡同，也许没有。至于能否缓解我的状态，我也记不得。只是到那种状态，我能想到这种方式去排解，多少也算是一种认同吧。</p>
<p>至于随笔（恰当称谓？），也能算是我的兴趣。偶尔写写东西，偶尔是真的偶偶尔。我从写文字当中获取的安静、专注、充实感显而易见，而文字大多都是当时的情绪与想法，可能脱胎于日记，但也将一些真实到黑暗的思考隐藏起来，多少能见光。不知道将自我产出的文字视若珍宝算不算病态，但我的确珍视，在我眼里这些文字能真切表示一种状态，这一刻我就是美化的真实的。至于这种方式何以占据重要的位置，大概因为内心戏丰富如我，不善表达情绪，多少是关掉大门开几扇窗。</p>
<p>其他能说的，读书、乒乓和游戏，目前的程度都还比较浅。曾经都热过一阵的行为，慢慢沉寂下来也沾上了尘土。所谓的我的兴趣，没得一项算是个人特长。骑车只是休闲，电影只是娱乐，随笔也只是偶尔的文艺，但是至少这些，能够成为生活的调剂，是能够令我感到舒适的生活方式。</p>
<h3 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h3><p>整理些技术向的学习内容，也多少要往这博客里边搁，况且，这本就是搭建这玩意的初衷。尽管不太喜欢用“工作”一词，但还是必须得慢慢习惯的。</p>
<p>求学时期拥有很好的学习环境，这段时间也就余下几年，两者都不得不承认。实验室的一些开发工作，还有自己看过的、学过的、实践过的一些内容，选择性的往这个博客里边搁。尽量减少一些空洞的文字（多一些图），减少随处可见的教程，多一点自己的总结，就是描述不规范，甚至有错误也无关紧要。他人的是他人的，转化为自己的才是自己的。尽管这些话可有可无，也就这样摆在这里了。</p>
<p>至于具体的工作内容，也没法细说。只是一段时间过去，觉得稍微闲下来时，慢悠悠写一点总结，多少能够察觉出自己在缓慢的生长，就很开心了。至于成长的快与慢，也不多去琢磨。吃饭慢，跑步慢，性子慢……真要快节奏起来，真就为难我“胖虎”了！</p>
<h3 id="成长"><a href="#成长" class="headerlink" title="成长"></a>成长</h3><p>现在过多的想法与计划一如既往地空白，只是希望每天有点进步，慢慢生长吧。</p>
<p>趁现在还有点记忆，罗列下自初中以来每个阶段自我希求的关键词。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">改变 ：白墙上丑陋的浓墨毛笔字，墨迹未干尚不回望，小屋也拆了，斑驳的往事不能再找回。</span><br><span class="line">掌控 ：年少时总希望能够决定自己的命运，可是连早睡早起也没有做到。</span><br><span class="line">自由 ：那四年时光，持续性潇洒，间歇性焦虑。觉睡得很饱，书读得也少。向自己一样平平淡淡。</span><br><span class="line">成长 ：有的人每天跑步，有的人会慢慢散步。蜗牛和火箭，都在自以为的前进。</span><br></pre></td></tr></table></figure>

<h3 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h3><p>今天是2019年9月20日，算是一个开始吧！</p>
<p><img src="https://cdn.jsdelivr.net/gh/biggfish3147/pics/blog/xingkong.jpeg" alt="星空"></p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>kindle电子书邮箱推送</title>
    <url>/2020/06/08/kindle%E7%94%B5%E5%AD%90%E4%B9%A6/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Kindle入手后已经吃过太多灰，<del>白嫖</del>收集的电子书资源怎么导入到Kindle设备都快忘记了，避免后续再次各处看教程，简单记录。</p>
<p><img src="https://cdn.jsdelivr.net/gh/biggfish3147/pics/blog/ilR0005.jpg" alt="人丑就要多读书"></p>
<h1 id="电子书资源"><a href="#电子书资源" class="headerlink" title="电子书资源"></a>电子书资源</h1><ul>
<li><del>有钱</del> 最好直接在Amazon官方商城购买（一步到位）</li>
<li><a href="https://www.jiumodiary.com/" target="_blank" rel="noopener">鸠摩</a></li>
<li><a href="https://sobooks.cc/" target="_blank" rel="noopener">SoBooks</a></li>
<li><a href="http://cn.epubee.com/books/" target="_blank" rel="noopener">ePUBee</a> （收费）</li>
</ul>
<h1 id="将电子书导入到Kindle"><a href="#将电子书导入到Kindle" class="headerlink" title="将电子书导入到Kindle"></a>将电子书导入到Kindle</h1><p>Kindle支持的电子书格式Kindle格式包括但不限于<code>.mobi</code>  <code>.azw</code> <code>.pdf</code>，不支持<code>.epub</code>格式，但可以通过电子书格式<a href="http://cn.epubee.com/" target="_blank" rel="noopener">转换工具</a>进行转换。</p>
<h2 id="USB数据线导入"><a href="#USB数据线导入" class="headerlink" title="USB数据线导入"></a>USB数据线导入</h2><p><strong>步骤</strong></p>
<ul>
<li>数据线（Micro USB口）连接Kindle与电脑</li>
<li>将电子书资源拷贝到Kindle磁盘的Documents文件夹  </li>
</ul>
<p><strong>注意</strong></p>
<ul>
<li>只能在Kindle设备上阅读，不能同步到同一账号下</li>
</ul>
<h2 id="邮箱推送"><a href="#邮箱推送" class="headerlink" title="邮箱推送"></a>邮箱推送</h2><p><strong>步骤</strong></p>
<ul>
<li>在Amazon账户下，管理我的内容与设备，进行个人文档设置（电子邮箱白名单）</li>
<li>将电子书资源（支持格式）作为邮件附件发送到***@kindle.cn邮件地址</li>
</ul>
<p><strong>注意</strong></p>
<ul>
<li>电子书资源能够同步到同一账号下</li>
</ul>
<h2 id="其他导入方式"><a href="#其他导入方式" class="headerlink" title="其他导入方式"></a>其他导入方式</h2><ul>
<li>公众号【亚马逊Kindle服务号】将文章推送到 Kindle</li>
<li>通过Calibre 传书到Kindle</li>
<li>通过手机发送传书到Kindle app（手机本地有电子书资源）</li>
</ul>
<h2 id="Kindle使用"><a href="#Kindle使用" class="headerlink" title="Kindle使用"></a>Kindle使用</h2><ul>
<li>关闭广告（First）</li>
<li>截屏（可以但没必要）</li>
<li>笔记/标注（可导出）</li>
<li>续航真的猛，内存也够大</li>
<li>Kindle神器Calibre（格式转换/推送）</li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://zhuanlan.zhihu.com/p/83882901" target="_blank" rel="noopener">如何把电子书导入到kindle？</a></li>
<li><a href="https://www.zhihu.com/question/273617420/answer/996496570" target="_blank" rel="noopener">你们都是从哪里找kindle电子书资源的？</a></li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/biggfish3147/pics/blog/ilF1005.jpg" alt="What？何不如买个iPad"></p>
]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>kindle</tag>
      </tags>
  </entry>
  <entry>
    <title>常见乱码问题及分析</title>
    <url>/2020/07/03/%E5%B8%B8%E8%A7%81%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98%E5%8F%8A%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>有一个现成的古老的web项目，技术栈包括<code>JSP</code> <code>JAVA</code> <code>MYSQL</code>，<code>MyEclipse 10.5</code>作为开发工具，开发环境<code>JDK1.7</code> <code>Tomcat7</code> <code>Mysql5.5</code>。</p>
<p>现在项目能够部署成功，正常访问。</p>
<p>但是当提交的表单数据中包含中文时，数据库存储的相关数据显示为???。</p>
<p>因为这个<code>BUG</code>，诞生这篇小结。</p>
<p><img src="https://cdn.jsdelivr.net/gh/biggfish3147/pics/blog/pk0001.png" alt="朋克风"></p>
<h1 id="常见乱码问题分析和总结"><a href="#常见乱码问题分析和总结" class="headerlink" title="常见乱码问题分析和总结"></a>常见乱码问题分析和总结</h1><p>本节内容选自<a href="https://www.ibm.com/developerworks/cn/java/analysis-and-summary-of-common-random-code-problems/index.html" target="_blank" rel="noopener">IBM Developer : 常见乱码问题分析和总结 </a></p>
<h2 id="编码与解码"><a href="#编码与解码" class="headerlink" title="编码与解码"></a>编码与解码</h2><p>计算机不能直接存储字母，数字，图片，符号等，计算机能处理和工作的唯一单位是”比特位（bit）”，一个比特位通常只有 0 和 1，是（yes）和否（no），真（true）或者假（false）等等我们喜欢的称呼。利用比特位序列来代表字母，数字，图片，符号等，我们就需要一个存储规则，不同的比特序列代表不同的字符，这就是所谓的”编码”。反之，将存储在计算机中的比特位序列（或者叫二进制序列）解析显示出来成对应的字母，数字，图片和符号，称为”解码”，如同密码学中的加密和解密，下面将详细解释编码解码过程中涉及到的一些术语：</p>
<p><strong>字符集合（Character set）</strong>：是各种文字和符号的总称，包括各国家文字、标点符号、图形符号、数字等，简单理解就是一个字库，与计算机以及编码无关。</p>
<p><strong>字符编码集（Coded character set）</strong>：是一组字符对应的编码（即数字），为字符集合中的每一个字符给予一个数字，如 Unicode 为每一个字符分配一个唯一的码点与之一一对应。</p>
<p><strong>字符编码（Character Encoding）</strong>：简单理解就是一个映射关系，将字符集对应的码点映射为一个个二进制序列，从而使得计算机可以存储和处理。常见的编码方式有 ASCII 编码、ISO-8859-1(不支持中文)、GBK、GB2312（中国编码，支持中文）、UTF-8 等等,详情见表 1。</p>
<p><strong>字符集（Charset）</strong>：包括编码字符集合和字符编码，如 ASCII 字符集、ISO-8859-X、GB2312 字符集（简中）、BIG5 字符集（繁中）、GB18030 字符集、Shift-JIS 等，即下文中提到的字符集。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">笔者注：</span><br><span class="line">这里提到的字符集合与字符集是不同的概念，后者包含前者。</span><br><span class="line">一般乱码现象都是因为中文数据导致的，汉字占用双字节，所以支持中文的编码方式（GBK、UTF<span class="number">-8</span>等）也就是可以支持对双字节汉字进行编码。</span><br></pre></td></tr></table></figure>

<p><strong>字符解码（Character Decoding）</strong>: 根据一定规则，将二进制序列映射成对应的正确字符串，即二进制序列–&gt;字符串，个人将其理解为”翻译”。</p>
<p><strong>Code Point</strong>：称作码点或码位，是组成编码空间（或代码页）的数值。例如，ASCII 码包含 128 个码点，范围是 0 到 7F（16 进制）；ISO-8859-1 包含 256 个码点，范围是 0 到 FF；而 Unicode 包含 1,114,112 个码点，范围是 0 到 10FFFF。Unicode 码空间划分为 17 个 Unicode 字符平面（基本多文种平面，16 个辅助平面），每个平面有 65,536（= 216）个码点。因此 Unicode 码空间总计是 17 x 65,536 = 1,114,112。</p>
<p><strong>Code Page</strong>：代码页或者内码表，是 IBM 早期称呼计算机的 BIOS 所支持的字符集编码（也称作 OEM 代码页）。Windows 系统在没有使用 UTF-16 之前，为了解决由于不同国家和地区采用的字符集不一致，很可能出现无法正常显示所有字符的问题，使用了代码页（Codepage）转换表的技术来过渡性的部分解决这一问题，即定义了一系列支持不同国家和地区所制定的字符集，被称为 Windows 代码页或 ANSI 代码页，然而代码页一般与其所对应的字符集之间并非完全相同，有时候会对字符集有所扩展，可以理解为一张字符-字节序列映射表，通过查表实现编码解码功能。操作系统中不同 Locale 设置默认使用不同的代码页。</p>
<p><strong>Locale</strong>：是指特定于某个国家或地区的一组设定，包括代码页，以及数字、货币、时间和日期的格式等。在 Windows 内部，有两个 Locale 设置：系统 Locale 和用户 Locale。系统 Locale 决定代码页，用户 Locale 决定数字、货币、时间和日期的格式。</p>
<h2 id="乱码产生原因"><a href="#乱码产生原因" class="headerlink" title="乱码产生原因"></a>乱码产生原因</h2><p>乱码产生的根源一般情况下可以归结为三方面即：编码引起的乱码、解码引起的乱码以及缺少某种字体库引起的乱码（这种情况需要用户安装对应的字体库），其中大部分乱码问题是由不合适的解码方式造成的，如图 3 所示的鱼骨图。</p>
<p>图 3. 乱码产生原因</p>
<p><img src="https://www.ibm.com/developerworks/cn/java/analysis-and-summary-of-common-random-code-problems/image003.jpg" alt="乱码产生原因"></p>
<h3 id="从普通用户角度分别阐述这几种原因导致的乱码表象和解决办法"><a href="#从普通用户角度分别阐述这几种原因导致的乱码表象和解决办法" class="headerlink" title="从普通用户角度分别阐述这几种原因导致的乱码表象和解决办法"></a>从普通用户角度分别阐述这几种原因导致的乱码表象和解决办法</h3><p>图 5. 编码方式引起的乱码剖析</p>
<p><img src="https://www.ibm.com/developerworks/cn/java/analysis-and-summary-of-common-random-code-problems/image005.jpg" alt="图 5. 编码方式引起的乱码剖析"></p>
<p>图 6. 不正确的解码方式引起的乱码</p>
<p><img src="https://www.ibm.com/developerworks/cn/java/analysis-and-summary-of-common-random-code-problems/image006.png" alt="图 6. 不正确的解码方式引起的乱码"></p>
<figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">笔者注：</span><br><span class="line">乱码有很多形式。</span><br><span class="line"><span class="string">"??"</span>通常是由于编码引起的乱码，出现?说明原始字符的信息已经丢失，这种情况下形成的乱码是不可逆的，也就是说无论用什么解码方式都不能正确显示字符。</span><br><span class="line"><span class="string">"ÄãºÃ£¬ÖÐ¹ú"</span>一般由解码方式不对引起的，乱码可逆，即可以通过乱码恢复获取原始的字符信息。</span><br></pre></td></tr></table></figure>

<h3 id="从编程角度分析出现乱码的场景和解决办法"><a href="#从编程角度分析出现乱码的场景和解决办法" class="headerlink" title="从编程角度分析出现乱码的场景和解决办法"></a>从编程角度分析出现乱码的场景和解决办法</h3><p>从编程角度来看，出现乱码的场景主要是有文本处理的时候，比如文件的新建和读取、复制和粘贴，导入和导出，打开和保存，数据存储和检索，显示，打印，分词处理，字符转换，规范化，搜索，整理和发送数据等，文本数据的示例包括平面文件，流文件，数据区域，目录名称，资源名称，用户标识等。图 9 是出现乱码的一个常见场景分类。</p>
<p>图 9. 出现乱码的场景</p>
<p><img src="https://www.ibm.com/developerworks/cn/java/analysis-and-summary-of-common-random-code-problems/image009.jpg" alt="出现乱码的场景"></p>
<p><strong>Web 程序中出现的乱码情况</strong></p>
<p>在 web 应用程序中，存在用户输入以及输出显示的地方都有可能存在编码解码，图 12 简要概括了 HTTP web 请求响应环节。</p>
<p>图 12. Web 请求响应环节中的编码解码</p>
<p><img src="https://www.ibm.com/developerworks/cn/java/analysis-and-summary-of-common-random-code-problems/image012.jpg" alt="请求响应环节中的编码解码"></p>
<p><strong>数据库操作过程中的乱码</strong></p>
<p>在实际应用中，和数据库操作相关的乱码可能出现在数据的导入和导出操作中，在整个过程中涉及到的字符集有服务器端数据库字符集、客户端操作系统字符集、客户端环境变量 nls_lang(lang_territory.charset)，这三个参数的工作流程如图 15 所示。如果这三个参数设置一样，整个数据库操作中就不会出现乱码问题，但是实际应用中客户端的情况复杂多样，很难保持三者一致，涉及到双字节字符就需要服务器端进行转码操作，而转码的桥梁就是 Unicode 字符集，这就要求数据库本身支持 UTF-8 编码方式。为了编码数据库操作过程中的乱码问题，在创建数据库的时候使用 UTF-8 编码方式，如果仅在某些列中使用多语言数据，则可以使用 SQL NCHAR 数据类型（NCHAR，NVARCHAR2 和 NCLOB）以 UTF-16 或 UTF-8 编码形式存储 Unicode 数据，避免存储空间的浪费。</p>
<p>图 15. Oracle 数据库字符集</p>
<p><img src="https://www.ibm.com/developerworks/cn/java/analysis-and-summary-of-common-random-code-problems/image015.jpg" alt="Oracle 数据库字符集"></p>
<h1 id="修改Windows的默认编码"><a href="#修改Windows的默认编码" class="headerlink" title="修改Windows的默认编码"></a>修改Windows的默认编码</h1><p>在Windows设置-时间与语言-语言-管理语言设置-更改系统区域设置中进行修改。</p>
<p>联想到一个现象：通过执行startup.bat文件开启tomcat服务器时，打印的启动日志出现乱码。</p>
<p>通过查询cmd的编码格式，并修改为utf-8编码格式，理论上能够解决上述乱码问题。实际上，执行chcp 65001，只是将当前cmd窗口的编码设置为utf-8。执行startup.bat时，会另外启动一个cmd进程，所以打印服务器启动日志的那个cmd窗口还是会有乱码。（除非从操作系统层面更改编码格式）</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//查看当前cmd的编码格式</span></span><br><span class="line"><span class="comment">//character code page</span></span><br><span class="line">chcp</span><br><span class="line"></span><br><span class="line"><span class="comment">//换成utf-8代码页</span></span><br><span class="line">chcp <span class="number">65001</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//换成默认的gbk</span></span><br><span class="line">chcp <span class="number">936</span></span><br></pre></td></tr></table></figure>

<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>现在回过头来想背景中的问题。??的出现有可能是字符的编码方式不对，导致通过任何解码方式都读不出正确的字符。那么在哪个环节出现了这个问题呢？通过测试，表单数据提交到服务端，服务端获取数据并打印，显示正常。说明在浏览器到web服务端的编码解码方式是OK的。那么再来，就是java程序代码中将正常的字符数据存入数据库时发生了问题，导致数据库中数据显示为??。于是考虑中文存入数据库的编码方式出了问题。事实也应该就是这样的。</p>
<p>【问题解决】java连接数据库的代码中，DBURL设置为<code>jdbc:mysql://localhost:3306/XXX?useUnicode=true&amp;characterEncoding=UTF-8</code>。重点就是后边的characterEncoding参数。</p>
<p>字符数据在二进制与可识读形式之间来回切换跳转，编码解码的步骤都是循环重复的。博大精深的中国汉字，到底在代码的世界里也很独特。</p>
<p>尽管问题解决，原因大概分析了，但真实的情形又是怎样的呢？谁又真正的可知？如果能够化身数据流，以数据本身的角度来看浏览器到数据库的往返之路，这该是很奇妙的想象与体验吧。</p>
<p><img src="https://cdn.jsdelivr.net/gh/biggfish3147/pics/blog/hacker.png" alt="hacker"></p>
]]></content>
      <categories>
        <category>常识</category>
      </categories>
      <tags>
        <tag>乱码</tag>
        <tag>编码</tag>
        <tag>解码</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo与GitHub Pages搭建独立博客</title>
    <url>/2020/04/29/%E6%90%AD%E5%BB%BA%E7%8B%AC%E7%AB%8B%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>博客其实在很久之前按照教程已经搭建完成，现在才回头来写教程步骤。有时候会想是否多此一举，毕竟网上现成的优秀的教程比比皆是。所以权且不说这是搭建基于Hexo的博客教程，只是一个简单的记录。</p>
<p>写一点东西，像擦肩而过的风。</p>
<p><img src="https://cdn.jsdelivr.net/gh/biggfish3147/pics/blog/7.jpg" alt="起飞"></p>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="GitHub-Pages"><a href="#GitHub-Pages" class="headerlink" title="GitHub Pages"></a>GitHub Pages</h2><p><code>GitHub Pages</code> 是一项<strong>静态站点托管服务</strong>，它直接从<code>GitHub</code> 上的仓库获取<code>HTML</code>、<code>CSS</code>和<code>JavaScript</code>文件，（可选）通过构建过程运行文件，然后发布网站。</p>
<p>有三种类型的 <code>GitHub Pages</code> 站点：项目、用户和组织。 项目站点连接到 <code>GitHub</code> 上托管的特定项目，用户和组织站点连接到特定的 <code>GitHub</code> 帐户。只能为每个 <code>GitHub</code>账户创建一个用户或组织站点。项目站点（无论是组织还是用户帐户拥有）没有限制。除非使用自定义域，否则用户和组织站点位于<code>http(s)://&lt;username&gt;.github.io</code> 或 <code>http(s)://&lt;organization&gt;.github.io</code>。</p>
<p>基于<code>GitHub Pages</code>搭建个人独立博客，即属于用户或组织站点。</p>
<p><code>GitHub Pages</code> 站点的发布来源是存储站点源文件的分支或文件夹。 所有站点都有默认的发布来源，项目站点还有其他可用的发布来源。用户和组织站点的默认发布来源是<code>master</code>分支。如果用户和组织站点的仓库是<code>master</code> 分支，您的站点将从该分支自动发布。无法为用户或组织站点选择不同的发布来源。</p>
<p><code>GitHub Pages</code> 站点受到以下使用限制的约束：</p>
<ul>
<li><code>GitHub Pages</code> 源仓库建议的限制为1GB。</li>
<li>发布的 <code>GitHub Pages</code> 站点不得超过 1 GB。</li>
<li><code>GitHub Pages</code> 站点的软带宽限制为每月 100GB。</li>
<li><code>GitHub Pages</code> 站点的软限制为每小时 10 次构建。</li>
</ul>
<h2 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h2><p><code>Hexo</code>是基于<code>Node.js</code>的快速、简洁且高效的博客框架。<code>Hexo</code> 使用 <code>Markdown</code>（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p>
<h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><ul>
<li>安装<code>Node.js</code></li>
<li>安装<code>Git</code></li>
<li>安装<code>Hexo</code><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//进入自己的博客文件夹(如/biggfish/blog)</span></span><br><span class="line">npm install hexo-cli -g </span><br><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><ul>
<li><p>初始化配置</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在Hexo安装目录下新建hexo文件夹，如 /biggfish/blog/hexo</span></span><br><span class="line">hexo inint</span><br></pre></td></tr></table></figure>
</li>
<li><p>本地生成与部署</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在hexo文件目录下执行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//生成静态文件</span></span><br><span class="line">hexo <span class="keyword">generate</span>  </span><br><span class="line"></span><br><span class="line"><span class="comment">//本地部署</span></span><br><span class="line">hexo server </span><br><span class="line"></span><br><span class="line"><span class="comment">//本地测试</span></span><br><span class="line">http:<span class="comment">//localhost:4000/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>配置<code>Hexo</code>与远程<code>GitHub</code>仓库关联</p>
<figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建`GitHub Pages`的站点发布来源，即username.github.io仓库</span></span><br><span class="line"><span class="comment">//配置远程连接的SSH密钥与公钥</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//将本地Hexo文件（静态网页）更新到GitHub 的username.github.io仓库</span></span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 复制Github仓库的ssh地址</span><br><span class="line"><span class="number">2.</span> 选择hexo文件夹下_config.yml文件，修改deploy相关信息</span><br><span class="line"><span class="symbol">  deploy:</span></span><br><span class="line"><span class="symbol">    type:</span> git</span><br><span class="line"><span class="symbol">    repository:</span> 刚复制的仓库ssh地址</span><br><span class="line"><span class="symbol">    branch:</span> master</span><br></pre></td></tr></table></figure>
</li>
<li><p>本地博客推送到远程仓库，<code>GitHub Pages</code>自动发布</p>
<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line"><span class="comment">//g-&gt;generate  d-&gt;deploy</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//生成静态文件，然后部署</span></span><br><span class="line">hexo <span class="keyword">g</span></span><br><span class="line">hexo <span class="built_in">d</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//或者联合执行</span></span><br><span class="line">hexo <span class="keyword">g</span> -<span class="built_in">d</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>访问博客 <a href="https://biggfish3147.github.io" target="_blank" rel="noopener">我的博客</a></p>
</li>
</ul>
<h1 id="发表文章"><a href="#发表文章" class="headerlink" title="发表文章"></a>发表文章</h1><p>注意用<code>markdown</code>语法编写文章。</p>
<ul>
<li><p><code>Front-matter</code>配置</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">博客伊始</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2019</span><span class="bullet">-09</span><span class="bullet">-20</span> <span class="number">23</span><span class="string">:29:47</span></span><br><span class="line"><span class="attr">comments:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">tags:</span> <span class="string">随笔</span></span><br><span class="line"><span class="attr">categories:</span> <span class="string">随笔</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">君不见，黄河之水天上来，奔流到海不复回</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 文章正文</span></span><br><span class="line"></span><br><span class="line"><span class="string">注:</span> <span class="string">Front-matter配置支持的变量，其值因主题不同而存在差异</span></span><br><span class="line"><span class="string">/**</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">layout:</span> <span class="string">页面布局（配合主题文档使用）</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">文章名称</span></span><br><span class="line"><span class="attr">date:</span> <span class="string">文章日期</span></span><br><span class="line"><span class="attr">comments:</span> <span class="string">文章是否开启评论</span></span><br><span class="line"><span class="attr">photos:</span> <span class="string">文章封面图（仅部分主题支持）</span></span><br><span class="line"><span class="attr">tags:</span> </span><br><span class="line"><span class="bullet">  -</span> <span class="string">文章标签一</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">文章标签二</span></span><br><span class="line"><span class="attr">categories:</span> <span class="string">文章分类</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">文章描述，即要在首页显示的摘要（仅部分主题支持）</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="string">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>推送文章</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//.md文章保存在/biggfish/blog/hexo/source/_posts中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//或者新建文章 默认放置在hexo/source/_posts中</span></span><br><span class="line">hexo <span class="keyword">new</span> <span class="string">"test"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Next主题新建页面</span></span><br><span class="line">hexo <span class="keyword">new</span> page <span class="string">"分类"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//照样在hexo文件夹下执行</span></span><br><span class="line"></span><br><span class="line">hexo d -g</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://help.github.com/cn/github/working-with-github-pages/about-github-pages" target="_blank" rel="noopener">GitHub Pages官方说明文档</a></li>
<li><a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">Hexo官方文档</a></li>
<li><a href="https://blog.csdn.net/qq_36759224/article/details/82121420#font_colorFF000_font_12" target="_blank" rel="noopener">使用 GitHub Pages和Hexo搭建自己的独立博客</a></li>
</ul>
]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>GitHub Pages</tag>
      </tags>
  </entry>
  <entry>
    <title>漫谈JSP</title>
    <url>/2020/05/09/%E6%BC%AB%E8%B0%88JSP/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>以前倒是知道<code>JSP</code>概念，但只能算是大概中的大概。今天因缘际会，又大致去查了些资料，然后就知道了个大概。比起<code>JSP</code>本身的语法规则，我对其由盛及衰的发展历史，倒表现出更大的兴趣。</p>
<p><img src="https://cdn.jsdelivr.net/gh/biggfish3147/pics/blog/ship.jpg" alt="古堡小船"></p>
<h1 id="JSP"><a href="#JSP" class="headerlink" title="JSP"></a>JSP</h1><p>全称<code>JavaServer Pages</code>，即Java服务器页面。它是一种 <strong>动态</strong> 网页技术标准，是一种服务器端的脚本语言（以<code>Java</code>作为脚本语言），但却和<code>PHP</code> <code>ASP</code>有着本质的区别，JSP本质上就是一种<code>Java Servlet</code>。</p>
<p>JSP技术使用JSP标签在HTML网页中插入Java代码，也就是将Java代码和特定变动内容嵌入到静态的页面中，实现以静态页面为模板，动态生成其中的部分内容。标签通常以&lt;%开头，以%&gt;结束。</p>
<p>JSP标签有多种功能，比如访问数据库、访问JavaBeans组件等，还可以在不同的网页中传递控制信息和共享信息。</p>
<h2 id="语法标准"><a href="#语法标准" class="headerlink" title="语法标准"></a>语法标准</h2><p>一个JSP页面可以被分为以下几部分：</p>
<ul>
<li>静态数据，如HTML</li>
<li>JSP指令，如include指令</li>
<li>JSP脚本元素（标签）和变量，如脚本变量request </li>
<li>JSP动作，如jsp:forward</li>
<li>用户自定义标签</li>
</ul>
<h2 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h2><p>通常我们在JSP文件中写Html代码，于是<strong>在使用上</strong>可以把它当作Html文件。比如我们访问某个网站的首页<code>http://yourdomainname:8080/index.jsp</code>，请求的就是这个JSP文件，这里理解上就可以认为JSP文件是一种<strong>动态资源</strong>（<code>Html/CSS</code>文件、图片等属于静态资源）。</p>
<p>当用户请求JSP文件时，服务器内部会经历一次JSP（动态资源）到HTML（静态资源）的转换，服务器会自动帮我们把JSP中的HTML片段和数据拼接成静态资源响应给浏览器。</p>
<p>网络服务器需要一个 JSP 引擎，也就是一个容器来处理 JSP 页面。容器负责截获对 JSP页面的请求。也就是说，<strong>JSP文件是运行在服务端</strong>而不是客户端的。</p>
<ul>
<li>JSP转换为Servlet</li>
</ul>
<p>JSP文件在运行时会被JSP引擎（引擎<code>jspServlet</code>本身也是Servlet，负责解释和执行JSP页面）转换成更原始的Servlet代码（.java后缀即java源文件）。在转换时，如果发现JSP文件中有任何语法错误，则中断转换过程，并向服务端和客户端输出错误信息。</p>
<blockquote>
<p>注:servlet是用Java语言编写的服务器端程序。主要功能是和浏览器进行交互，生成页面展示。</p>
</blockquote>
<ul>
<li>转换为.class文件</li>
</ul>
<p>JSP被JSP引擎转换为Servlet后，将被编译成Servlet的class文件（字节码文件）。也就是通常的.java文件到.class文件的编译过程。</p>
<ul>
<li>Servlet容器处理</li>
</ul>
<p>.jsp文件转换之后的.class文件能够被JVM（Java虚拟机）执行，通过加载类、初始化、实例化等步骤，将执行结果（Html代码-静态文件）传递给（处理这个jsp请求的Servlet程序中的）response对象，进而通过Web服务器响应给浏览器。</p>
<ul>
<li>浏览器解析Html</li>
</ul>
<p>浏览器只能够处理并渲染静态资源。虽然请求的是.jsp文件，但是获得的响应是完完全全的Html文件，于是解析Html代码并将请求的页面显示。</p>
<h2 id="JSP、PHP与ASP"><a href="#JSP、PHP与ASP" class="headerlink" title="JSP、PHP与ASP"></a>JSP、PHP与ASP</h2><ul>
<li>PHP  </li>
</ul>
<p>PHP是一种嵌入HTML页面中的脚本语言，使Web开发者能够快速地写出动态产生页面。</p>
<p>PHP语法简单，非常易学易用，很利于快速开发各种功能不同的定制网站（<code>APACHE＋PHP＋MYSQL</code>搭配），但因为结构上的缺陷，使的PHP在复杂的大型项目上的开发和维护都比较困难。</p>
<ul>
<li>ASP</li>
</ul>
<p>ASP（Active Server Pages）是微软的Windows IIS系统自带的脚本语言，利用它可以执行动态的Web服务应用程序。</p>
<p>和PHP一样，ASP简单而易于维护，很适合小型网站应用，通过DCOM和MTS技术，ASP甚至还可以完成小规模的企业应用，但ASP的致命缺点就是不支持跨平台的系统，在大型项目开发和维护上非常困难。</p>
<ul>
<li>JSP</li>
</ul>
<p>JSP（JavaServer Pages）是Sun公司推出的一种动态网页技术。JSP本身虽然也是脚本语言(以Java作为脚本语言)，但是却和PHP、ASP有着本质的区别。PHP和ASP都是由语言引擎解释执行程序代码，而JSP代码却被编译成Servlet并由Java虚拟机执行，这种编译操作仅在对JSP页面的第一次请求时发生。因此普遍认为JSP的执行效率比PHP和ASP都高。</p>
<p>JSP是一种服务器端的脚本语言，最大的好处就是开发效率较高，但是因为其业务规则代码与页面代码混为一团，不利于维护，因此并不适应大型应用的要求，取而代之的是基于MVC的Web架构。</p>
<p>MVC的核心思想是将应用分为模型、视图和控制器三部分。模型是指应用程序的数据，以及对这些数据的操作；视图是指用户界面；控制器负责用户界面和程序数据之间的同步。通过MVC的Web架构，可以弱化各个部分的耦合关系，并将业务逻辑处理与页面以及数据分离开来，这样当其中一个模块的代码发生改变时，并不影响其他模块的正常运行，所以基于MVC的Web架构更适应于大型应用开发的潮流。</p>
<p><img src="https://cdn.jsdelivr.net/gh/biggfish3147/pics/blog/planet.jpg" alt="星球"></p>
<h1 id="由盛及衰"><a href="#由盛及衰" class="headerlink" title="由盛及衰"></a>由盛及衰</h1><h2 id="故事背景"><a href="#故事背景" class="headerlink" title="故事背景"></a>故事背景</h2><p>1995年，SUN公司发布了Java。创始人之一望着手中的咖啡，灵机一动，取名Java。宣传口号是”一次编写，到处运行”（Write Once, Run Anywhere）。</p>
<blockquote>
<p>注：一次编写，到处运行，也就是跨平台了。</p>
</blockquote>
<p>几乎同年，后来被黑为“世界上最好的语言”PHP也发布了。WordPress和MediaWiki就是有出息的两个儿子。</p>
<p>也是1995年，一个名叫布兰登·艾奇的技术员，为应付任务花了10天设计出JavaScript（这名字就是蹭Java热度，JavaScript与Java只有半毛钱关系）。这个借鉴C、Java、Scheme和Self等语言设计出来的冬冬，初始版本很不好用，但好在后期救回来了，并逐渐走上人生巅峰。</p>
<blockquote>
<p>注：一个完整的JavaScript实现应由三个部分组成:ECMAScript、DOM、BOM</p>
</blockquote>
<h2 id="出道往事"><a href="#出道往事" class="headerlink" title="出道往事"></a>出道往事</h2><h3 id="黑世纪–Servlet写Html代码"><a href="#黑世纪–Servlet写Html代码" class="headerlink" title="黑世纪–Servlet写Html代码"></a>黑世纪–Servlet写Html代码</h3><p>下述是MyEclipse新建Servlet时显示的模板。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HistoryServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Constructor of the object.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">HistoryServlet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Destruction of the servlet. &lt;br&gt;</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>.destroy(); <span class="comment">// Just puts "destroy" string in log</span></span><br><span class="line">		<span class="comment">// Put your code here</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * The doGet method of the servlet. &lt;br&gt;</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * This method is called when a form has its tag value method equals to get.</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> request the request send by the client to the server</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> response the response send by the server to the client</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> ServletException if an error occurred</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> IOException if an error occurred</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">		response.setContentType(<span class="string">"text/html"</span>);</span><br><span class="line">		PrintWriter out = response.getWriter();</span><br><span class="line">		out.println(<span class="string">"&lt;!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\"&gt;"</span>);</span><br><span class="line">		out.println(<span class="string">"&lt;HTML&gt;"</span>);</span><br><span class="line">		out.println(<span class="string">"  &lt;HEAD&gt;&lt;TITLE&gt;A Servlet&lt;/TITLE&gt;&lt;/HEAD&gt;"</span>);</span><br><span class="line">		out.println(<span class="string">"  &lt;BODY&gt;"</span>);</span><br><span class="line">		out.print(<span class="string">"    This is "</span>);</span><br><span class="line">		out.print(<span class="keyword">this</span>.getClass());</span><br><span class="line">		out.println(<span class="string">", using the GET method"</span>);</span><br><span class="line">		out.println(<span class="string">"  &lt;/BODY&gt;"</span>);</span><br><span class="line">		out.println(<span class="string">"&lt;/HTML&gt;"</span>);</span><br><span class="line">		out.flush();</span><br><span class="line">		out.close();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * The doPost method of the servlet. &lt;br&gt;</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * This method is called when a form has its tag value method equals to post.</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> request the request send by the client to the server</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> response the response send by the server to the client</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> ServletException if an error occurred</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> IOException if an error occurred</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">		response.setContentType(<span class="string">"text/html"</span>);</span><br><span class="line">		PrintWriter out = response.getWriter();</span><br><span class="line">		out.println(<span class="string">"&lt;!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\"&gt;"</span>);</span><br><span class="line">		out.println(<span class="string">"&lt;HTML&gt;"</span>);</span><br><span class="line">		out.println(<span class="string">"  &lt;HEAD&gt;&lt;TITLE&gt;A Servlet&lt;/TITLE&gt;&lt;/HEAD&gt;"</span>);</span><br><span class="line">		out.println(<span class="string">"  &lt;BODY&gt;"</span>);</span><br><span class="line">		out.print(<span class="string">"    This is "</span>);</span><br><span class="line">		out.print(<span class="keyword">this</span>.getClass());</span><br><span class="line">		out.println(<span class="string">", using the POST method"</span>);</span><br><span class="line">		out.println(<span class="string">"  &lt;/BODY&gt;"</span>);</span><br><span class="line">		out.println(<span class="string">"&lt;/HTML&gt;"</span>);</span><br><span class="line">		out.flush();</span><br><span class="line">		out.close();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Initialization of the servlet. &lt;br&gt;</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> ServletException if an error occurs</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">		<span class="comment">// Put your code here</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上古时代，就是这样一行一行写入Html代码到response对象中的。美工做好Html的静态页面，扔给Java程序员。Java程序员逐条拷贝Html代码，并于后端数据拼接，最后返回带数据的完整的Html。</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">out</span>.println("&lt;span&gt;用户名："+<span class="keyword">user</span>.name+&lt;"/span&gt;");</span><br></pre></td></tr></table></figure>

<h3 id="出道–Servlet披着JSP的壳"><a href="#出道–Servlet披着JSP的壳" class="headerlink" title="出道–Servlet披着JSP的壳"></a>出道–Servlet披着JSP的壳</h3><p>友商PHP这时候就很优秀，它们选择在html页面中嵌入相应语言来引入动态数据。</p>
<p>细想起来，目标无非就是在最终输出的html的代码中嵌入后台数据。可以在Html文件中嵌入动态数据，也可以在动态页面中嵌入Html静态数据，殊途同归。</p>
<p>于是，JSP诞生了。虽然名字叫做JSP，但JSP实质上就是Servlet实例。暗世纪手动拷贝HTML代码的日子结束了，这些操作交给了JSP引擎（即jspServlet）去执行。</p>
<p>JSP = Html + Java片段。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">%@</span> <span class="attr">page</span> <span class="attr">language</span>=<span class="string">"java"</span> <span class="attr">contentType</span>=<span class="string">"text/html;charset=UTF-8"</span></span></span><br><span class="line"><span class="tag">	<span class="attr">pageEncoding</span>=<span class="string">"UTF-8"</span>%&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">%@</span> <span class="attr">page</span> <span class="attr">import</span>=<span class="string">"com.py.vo.Member"</span>%&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">%</span></span></span><br><span class="line"><span class="tag"><span class="attr">String</span> <span class="attr">path</span> = <span class="string">request.getContextPath();</span></span></span><br><span class="line"><span class="tag"><span class="attr">String</span> <span class="attr">basePath</span> = <span class="string">request.getScheme()+</span>"<span class="attr">:</span>//"+<span class="attr">request.getServerName</span>()+"<span class="attr">:</span>"+<span class="attr">request.getServerPort</span>()+<span class="attr">path</span>+"/";</span></span><br><span class="line"><span class="tag">%&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">xmlns</span>=<span class="string">"http://www.w3.org/1999/xhtml"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">base</span> <span class="attr">href</span>=<span class="string">"&lt;%=basePath%&gt;"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>电子商务网站<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"css/style.css"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">type</span>=<span class="string">"text/css"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">	<span class="function"><span class="keyword">function</span> <span class="title">quit</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">		<span class="keyword">if</span> (confirm(<span class="string">"没有要买的东西了吗？"</span>)) &#123;</span></span><br><span class="line"><span class="javascript">			<span class="built_in">window</span>.location.href = <span class="string">"MemberServlet.do?method=logoutMember"</span>;</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"header"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"logo"</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"index.jsp"</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"images/logo.gif"</span> <span class="attr">width</span>=<span class="string">"135"</span></span></span><br><span class="line"><span class="tag">				<span class="attr">height</span>=<span class="string">"55"</span> /&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">form</span> <span class="attr">name</span>=<span class="string">"form"</span> <span class="attr">method</span>=<span class="string">"post"</span></span></span><br><span class="line"><span class="tag">			<span class="attr">action</span>=<span class="string">"GoodsServlet.do?method=selectByKeywords"</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"search"</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">class</span>=<span class="string">"input1"</span> <span class="attr">name</span>=<span class="string">"keywords"</span>/&gt;</span> <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"image"</span></span></span><br><span class="line"><span class="tag">					<span class="attr">src</span>=<span class="string">"images/icon_search.gif"</span> <span class="attr">class</span>=<span class="string">"input2"</span> /&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">%</span></span></span><br><span class="line"><span class="tag">			<span class="attr">if</span> (<span class="attr">session.getAttribute</span>("<span class="attr">member</span>") == <span class="string">null)</span> &#123;</span></span><br><span class="line"><span class="tag">		%&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"login"</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"fg-memberLogin.jsp"</span> <span class="attr">class</span>=<span class="string">"a1"</span>&gt;</span>登录<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">%</span></span></span><br><span class="line"><span class="tag">			&#125; <span class="attr">else</span> &#123;</span></span><br><span class="line"><span class="tag">				<span class="attr">Member</span> <span class="attr">member</span> = <span class="string">(Member)</span> <span class="attr">session.getAttribute</span>("<span class="attr">member</span>");</span></span><br><span class="line"><span class="tag">		%&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"login"</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">font</span> <span class="attr">class</span>=<span class="string">"red"</span>&gt;</span><span class="tag">&lt;<span class="name">%=member.getAccount()%</span>&gt;</span><span class="tag">&lt;/<span class="name">font</span>&gt;</span>，欢迎回来&amp;nbsp;&amp;nbsp;<span class="tag">&lt;<span class="name">a</span></span></span><br><span class="line"><span class="tag">				<span class="attr">href</span>=<span class="string">"javascript:quit()"</span>&gt;</span>退出<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">%</span></span></span><br><span class="line"><span class="tag">			&#125;</span></span><br><span class="line"><span class="tag">		%&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>JSP特点</p>
<ul>
<li>跨平台（以Java作为脚本）</li>
<li>业务代码分离（数据对象模型）</li>
<li>组件重用（JavaBean）</li>
<li>预编译（首次请求JSP是编译执行后，class文件被保存）</li>
</ul>
<h3 id="危机–优点也会是缺点"><a href="#危机–优点也会是缺点" class="headerlink" title="危机–优点也会是缺点"></a>危机–优点也会是缺点</h3><p>JSP文件能够同时写Html和Java，但是。</p>
<ol>
<li><p>动态和静态资源放在一起，一旦服务器出现状况，前后台一起玩完，用户体验极差。</p>
</li>
<li><p>一旦jsp出现了问题，就需要前端后端发开人员一块来分析解决，效率低。</p>
</li>
<li><p>jsp无法使用nginx等。</p>
</li>
<li><p>jsp页面复杂，难以修改。</p>
</li>
<li><p>第一次加载jsp需要编译成servlet，时间久，而且业务量大的时候，jsp负担太大。</p>
</li>
</ol>
<p>于是，前后端分离就出现了。</p>
<h3 id="落寞–前后端分离燃烧起来"><a href="#落寞–前后端分离燃烧起来" class="headerlink" title="落寞–前后端分离燃烧起来"></a>落寞–前后端分离燃烧起来</h3><p>前后端分离其实就是后端工程师只关注于后端业务逻辑的开发，不再处理前端问题。前端工程师只关注于自己的页面开发。需要数据交互的时候，两者会有一份接口文档。</p>
<p>然后新兴SpringMVC、RestFul、Ajax …</p>
<blockquote>
<p>注：MVC是WEB开发模式，并不是SpringMVC专属</p>
</blockquote>
<p>然后前端也不再是Web页面，移动端又蓬勃起来…</p>
<p>JSP也就这样渐渐的完成它的时代使命，告别曾经辉煌过的舞台，偶尔在一些老旧的项目中散发着微光…</p>
<h1 id="我的小结"><a href="#我的小结" class="headerlink" title="我的小结"></a>我的小结</h1><p>JSP的盛衰似乎令人唏嘘，但这就是技术的发展与进步。它已经完成了它的使命，但这并不意味着JSP应该被描述过时或者应该被抛弃，在适当的场景JSP还是有用武之地的，就像PHP依然那么活跃。</p>
<p>具体的JSP技术与语法，是现在的我不需要去花时间看的。近来觉得编程里边的知识很丰富，面面俱到不大现实也不应该。可以知道很多，但是专注的点也就只能那么几个。正所谓涉猎广泛，重点捕捉。</p>
<p>然后就是觉得学习编程不再纯粹只是看技术细节，还需要提升一点看语言的设计以及系统的整体架构。当然我现在还不会，就怎么说呢，技术是看代码和写代码，思想是像写诗一样优雅的造轮子。</p>
<p>胡言胡语，小结完毕。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://zhuanlan.zhihu.com/p/42343690" target="_blank" rel="noopener">知乎：浅谈JSP</a><br><a href="https://baijiahao.baidu.com/s?id=1645273953613115391&wfr=spider&for=pc" target="_blank" rel="noopener">曾经风光无限的jsp，为什么现在很少有人用了呢？</a><br><a href="https://www.cnblogs.com/lixuwu/articles/4499883.html" target="_blank" rel="noopener">php与jsp的区别</a><br><a href="https://zhuanlan.zhihu.com/p/71937497" target="_blank" rel="noopener">再见，JSP</a></p>
<p><img src="https://cdn.jsdelivr.net/gh/biggfish3147/pics/blog/yellowman.jpg" alt="小黄人"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>概念</tag>
        <tag>JSP</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈图像</title>
    <url>/2020/06/01/%E6%B5%85%E8%B0%88%E5%9B%BE%E5%83%8F/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>一切要从图像分辨率说起。前不久问过自己一个问题：<strong>小米6只有1920x1080的分辨率为什么能拍出4032x3016px的照片？</strong></p>
<p>不知当时脑袋想什么，问出这样一个特别蠢的问题。但它居然就这样作为一个导火索，让我不得不去了解一下关于图像的基本知识。</p>
<p>这里需要说明的是，这个问题本身就是个问题。小米6的分辨率1920x1080是说的屏幕分辨率，而4032x3016px的照片是相机拍出来的图像分辨率，也就是米6后置的1200万像素摄像头拍出来的。一个是屏幕显示分辨率，另一个是拍照图像分辨率，就没得啥关联的。</p>
<p>然后又因为接触<code>React Native</code>，知道其组件的宽高用的是逻辑像素作为单位。之前买的kindle参数里其中一项是PPI，笔记本外设显示器4K屏……</p>
<p>于是就简单整理一下图像基础知识及相关概念，权作了解。</p>
<p><img src="https://cdn.jsdelivr.net/gh/biggfish3147/pics/blog/ilF0001.jpg" alt="图像啊图像"></p>
<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>位图和矢量图是计算机图形中的两大概念。</p>
<h2 id="位图"><a href="#位图" class="headerlink" title="位图"></a>位图</h2><p><strong>位图</strong>（bitmap）也叫点阵图、栅格图像、<strong>像素图</strong>。<strong>构成位图的最小单位是像素</strong>，位图就是依靠像素阵列的排列来实现其显示效果的，缩放位图会导致失真（边缘锯齿）。例如放大后的位图出现“马赛克”。</p>
<p><strong>位图图像善于重现颜色的细微层次</strong>，能够制作出色彩和亮度变化丰富的图像，可逼真地再现这个世界，文件庞大，<strong>不能随意缩放，打印和输出的精度是有限的。</strong></p>
<p><strong>位图的文件类型</strong>很多，如.bmp、.pcx、.gif、.jpg、.tif等。同样的图形，存盘成以上几种文件时文件的字节数会有一些差别，尤其是jpg格式，它的大小只有同样的bmp格式的1/20到1/35，这是因为它们的点矩阵经过了复杂的压缩算法的缘故。</p>
<p><strong>位图图像面积越大，图像文件的色彩越丰富，文件的字节数就越多。</strong></p>
<h2 id="矢量图"><a href="#矢量图" class="headerlink" title="矢量图"></a>矢量图</h2><p><strong>矢量图</strong>（vector）也叫向量图，是一种<strong>缩放不失真</strong>的图像格式。矢量图是通过多个对象的组合生成的，对其中的每一个对象的纪录方式，都是以数学函数来实现的，也就是说，矢量图实际上并不是像位图那样纪录画面上每一点的信息，而是纪录了元素形状及颜色的算法，当你打开矢量图的时候，软件利用图行对应的函数进行运算，将运算结果[图形的形状和颜色]显示给你看。</p>
<p>矢量图形能<strong>重现清晰的轮廓</strong>，线条非常光滑、且<strong>具有良好的缩放性</strong>。因为图像中保存的是线条和图块的信息，与分辨率和图形大小无关，只与图像的复杂程度有关，所以图像文件所占的存储空间较小（图像不复杂情况下）。</p>
<p>与位图相比，在显示和打印方面都快的多；<strong>图形不真实生动，颜色不丰富</strong>。无法像照片一样真实地再现这个世界的景色。（矢量图基本都需要专门软件打开）</p>
<p><strong>矢量图形格式</strong>也很多，常见的如.SVG。</p>
<p>矢量图形文件的规律：</p>
<ul>
<li>可以无限放大图形中的细节，不用担心会造成失真和色块。</li>
<li>一般的线条的图形和卡通图形，存成矢量图文件就比存成位图文件要小很多。</li>
<li>存盘后<strong>文件的大小</strong>与图形中<strong>元素的个数</strong>和每个<strong>元素的复杂程度</strong>成正比。而与图形面积和色彩的丰富程度无关。（元素的复杂程度指的是这个元素的结构复杂度，如五角星就比矩形复杂、一个任意曲线就比一个直线段复杂）。</li>
<li>通过软件，<strong>矢量图可以轻松地转化为位图，而位图转化为矢量图就需要经过复杂而庞大的数据处理</strong>，而且生成的矢量图的质量绝对不能和原来的图形比拟。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/biggfish3147/pics/blog/ilF0002.jpg" alt="图像啊图像"></p>
<h2 id="一些单位"><a href="#一些单位" class="headerlink" title="一些单位"></a>一些单位</h2><p>绝对单位与相对单位。比如设备尺寸5.15 inch就是绝对的物理长度，像素（pixel）就是相对单位，1英寸显示屏可以只有1个像素，也可以有100个像素。<strong>相同面积不同分辨率的显示屏，其像素点大小就不相同。</strong></p>
<p><strong>px</strong>：<code>pixel</code>，像素，是<strong>组成数字图像的基本单元</strong>。这种基本单元越多，越能呈现出图像的细节，图像就越清晰。像素的大小是没有固定长度的，不同设备上一个单位像素色块的大小是不一样的。</p>
<p><strong>ppi</strong> ：<code>pixels per inch</code>,等于屏幕对角线像素点／屏幕对角线物理宽度，是每英寸对角线上所拥有的像素（pixel）数目，通常也叫<strong>像素密度</strong>。手机屏幕的PPI当达到一定数值（300ppi）时，人眼就分辨不出颗粒感了。</p>
<p><strong>dpi</strong>：<code>dots per inch</code>,是每英寸所能打印的点数，通常也叫<strong>打印精度</strong>。如：打印机输出可达600DPI的分辨率，表示打印机可以在每一平方英寸的面积中可以输出600X600＝360000个输出点。大多数情况下，PPI与DPI的数值是相等的。</p>
<p><strong>dp</strong>：<code>density-independent pixels</code>,一种基于屏幕密度的抽象单位。在每英寸160点的显示器上，1dp = 1px。<a href="https://developer.android.com/guide/practices/screens_support.html" target="_blank" rel="noopener">dp的提出</a>是为了解决控件对不同屏幕的适配问题。</p>
<p><strong>sp</strong>：<code>scale-independent pixel</code>，与缩放无关的抽象像素，安卓开发用的字体大小单位。一般情况下可认为sp=dp。</p>
<p><strong>density</strong> ：密度。density ≈ 设备PPI/160PPI。比如我是320PPI设备，density＝320PPI/160PPI=2;density是一个int类型的值。</p>
<p><strong>运算案例</strong></p>
<p>小米6设备参数：显示屏尺寸5.15英寸（1 inch=2.54 cm），分辨率1920x1080px</p>
<p>计算得：PPI=428 ，density≈3，1dp=2.67px≈3px。</p>
<h2 id="分辨率"><a href="#分辨率" class="headerlink" title="分辨率"></a>分辨率</h2><p>分辨率，又称解析度。分辨率=画面水平方向的像素值x画面垂直方向的像素值，分为 <strong>屏幕分辨率</strong>和<strong>图像分辨率</strong>。</p>
<p>显示分辨率（屏幕分辨率）是屏幕图像的精密度，是指<strong>显示器所能显示的像素有多少</strong>。由于屏幕上的点、线和面都是由像素组成的，显示器可显示的像素越多，画面就越精细，同样的屏幕区域内能显示的信息也越多。显示分辨率一定的情况下，显示屏越小图像越清晰，反之，显示屏大小固定时，显示分辨率越高图像越清晰。</p>
<p>屏幕分辨率1920x1080（16:9显示屏），就是说设备屏幕的水平方向上有1920个像素点，垂直方向上有1080个像素点。<strong>同一台硬件设备上的屏幕分辨率、像素块大小是不会变的（倾向于说显示器分辨率）</strong>。PC电脑上之所以可以调整屏幕分辨率，其实是通过算法转换实现的。</p>
<p><strong>图像分辨率是指每英寸图像内的像素点数</strong>（这种定义方式更精准）。图像分辨率是有单位的，叫 像素每英寸。分辨率越高，像素的点密度越高（图像尺寸一定时），图像越逼真。</p>
<p>分辨率和清晰度不能对等，虽然<strong>很多情况下高分辨率的确意味着高清晰度</strong>。比如一张1920x1080尺寸的图片，放在1920x1080分辨率的PC屏幕上显示没问题（大小合适），但放在4K屏上就会发现图片变模糊（失真）了（因为4K屏幕大，图像放大失真）。又比如1920x1080和1280x720的图片作为手机壁纸，其实清晰度看起来差不多的。</p>
<p><img src="https://cdn.jsdelivr.net/gh/biggfish3147/pics/blog/ilF0012.jpg" alt="图像啊图像"></p>
<h1 id="图像深度与像素深度"><a href="#图像深度与像素深度" class="headerlink" title="图像深度与像素深度"></a>图像深度与像素深度</h1><p>像素深度和图像深度是两个相互关联但又有所不同的两个概念。</p>
<h2 id="像素深度"><a href="#像素深度" class="headerlink" title="像素深度"></a>像素深度</h2><p><strong>像素深度</strong>是指<strong>存储每个像素所用的位数</strong>，它也是用来度量图像的分辨率。</p>
<p><strong>像素深度决定彩色图像的每个像素可能有的颜色数，或者确定灰度图像的每个像素可能有的灰度级数</strong>。例如，一幅彩色图像的每个像素用R，G，B三个分量表示，若每个分量用8位，那么一个像素共用24位表示，就说像素的深度为24，每个像素可以是16 777 216（2的24次方）种颜色中的一种。在这个意义上，往往把像素深度说成是图像深度。表示一个像素的位数越多，它能表达的颜色数目就越多，而它的深度就越深。</p>
<h2 id="图像深度"><a href="#图像深度" class="headerlink" title="图像深度"></a>图像深度</h2><p><strong>图像深度</strong>是指<strong>像素深度中实际用于存储图像的灰度或色彩所需要的比特位数</strong>。假定图像的像素深度为16bit，但用于表示图像的灰度或色彩的位数只有15位，则图像的图像深度为15。</p>
<p>在用二进制数表示彩色图像的像素时，除R，G，B分量用固定位数表示外，往往还增加1位或几位作为属性(Attribute)位。例如，RGB 5∶5∶5表示一个像素时，用2个字节共16位表示，其中R，G，B各占5位，剩下一位作为属性位。在这种情况下，像素深度为16位，而图像深度为15位。</p>
<h2 id="图像通道"><a href="#图像通道" class="headerlink" title="图像通道"></a>图像通道</h2><p>我们都知道颜色的三元素 Red, Green, Blue。 如果是深度为24=3*8，我们刚好就可以用第一个8位存储Red值，第二个存储Green值，第三个存储Blue值, 2的8次方刚好是255,所以我们一般看到的RGB值都是(0-255,0-255,0-255)这样的值。如果用rgb来表示图片的颜色值，我们称这样的图片通道为三。<br>每个像素点都有3个值表示 ，所以就是3通道；也有4通道的图（RGB+alpha），灰度图一般为单通道。</p>
<h2 id="灰度图像"><a href="#灰度图像" class="headerlink" title="灰度图像"></a>灰度图像</h2><p><strong>灰度</strong>也可以认为是亮度，简单说就是<strong>色彩的深浅程度</strong>。</p>
<p>灰度图像是二值图像的进化版本，是彩色图像的退化版，也就是灰度图保存的信息没有彩色图像多，但比二值图像多，灰度图只包含一个通道的信息，而彩色图通常包含三个通道的信息。</p>
<p><strong>灰度数字图像是每个像素只有一个采样颜色的图像</strong>（灰度图没有色彩）。这类图像通常显示为从最暗黑色到最亮的白色的灰度，尽管理论上这个采样可以任何颜色的不同深浅，甚至可以是不同亮度上的不同颜色。灰度图像与黑白图像不同，在计算机图像领域中黑白图像只有黑白两种颜色，灰度图像在黑色与白色之间还有许多级的颜色深度。</p>
<p><strong>彩色图像可以二值化和灰度化</strong>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/biggfish3147/pics/blog/ilF1021.jpeg" alt="图像啊图像"></p>
<h1 id="图像格式"><a href="#图像格式" class="headerlink" title="图像格式"></a>图像格式</h1><p>BMP、PNG、GIF、TIF和JPG格式的文件是位图文件，文件的扩展明指明了图像文件的标准。SVG是矢量图文件格式。<font color="red">图片文件格式本质上是一种对图片进行压缩进而减少文件大小的解决方案。</font></p>
<p>如果将图像原始格式直接存储到文件中将会非常大，比如一个5000x5000 24位图，所占文件大小为5000x5000x3字节=71.5MB, 其大小非常可观。<br>如果用zip或rar之类的通用算法来压缩像素数据，得到的压缩比例通常不会太高，因为这些压缩算法没有针对图像数据结构进行特殊处理。</p>
<h2 id="jpeg"><a href="#jpeg" class="headerlink" title="jpeg"></a>jpeg</h2><p>全称<code>JointPhotographicExpertsGroup</code>，<br>JEPG格式，也叫做JPG或JPE格式，是最常用的一种文件格式。<strong>实际测试.jpeg后缀文件更改为.jpg后缀依旧可读</strong>。</p>
<p>JPEG格式的压缩技术十分先进，<strong>能够将图像压缩在很小的储存空间</strong>，不过这种压缩是<strong>有损耗</strong>的，过度压缩会降低图片的质量。JPEG格式压缩的主要是高频信息，对色彩的信息保留较好，因此特别适合应用于互联网，可减少图像的传输和加载时间。</p>
<p>jpeg没有透明信息。<strong>jpeg比较适合用来存储相机拍出来的照片，这类图像用jpeg压缩后的体积比较小</strong>。其使用的具体算法核心是离散余弦变换、Huffman编码、算术编码等技术。</p>
<h2 id="png"><a href="#png" class="headerlink" title="png"></a>png</h2><p>全称<code>Portable Network Graphic Format</code>。<br>png 最重要的特点是<strong>支持alpha 通道透明度</strong>，也就是说，<strong>PNG图片支持透明背景</strong>。一般来说彩色图像是24位3通道图像，png格式的图像就是4通道的。</p>
<p>png的设计目的是试图替代gif和tiff。png是一种支持无损压缩的图像格式（从LZ77派生的无损数据压缩算法），没有可调整的压缩质量设置（有损程度）。虽然PNG提供的压缩量比JPEG少，但PNG图片却比JPEG图片有更小的文档尺寸，因此现在越来越多的网络图像开始采用PNG格式。</p>
<p><strong>jpeg比较适合存储色彩“杂乱”的拍摄图片，png比较适合存储几何特征强的图形类图片（颜色值少）</strong>。</p>
<h2 id="gif"><a href="#gif" class="headerlink" title="gif"></a>gif</h2><p>全称<code>Graphics Interchange Format</code>。<br>GIF也是一种压缩的图片格式，分为动态GIF和静态GIF两种。</p>
<p>GIF格式的最大特点是<strong>支持动态图片</strong>（多帧），并且支持透明背景。网络上绝大部分动图、表情包都是GIF格式的，相比与动画，GIF动态图片占用的存储空间小，加载速度快，因此非常流行。</p>
<h2 id="psd"><a href="#psd" class="headerlink" title="psd"></a>psd</h2><p>全称<code>Photoshop Document</code>。<br>PSD格式是Photoshop默认的存储格式，<strong>适用于存储源文档和工作文件</strong>，修改起来比较方便。<br>PSD格式的最大特点是可以保留透明度、图层、路径、通道等PS处理信息，但是需要专业的图形处理软件才能打开。PSD格式的缺点是体积庞大，十分占用存储空间。</p>
<h2 id="tiff"><a href="#tiff" class="headerlink" title="tiff"></a>tiff</h2><p>全称<code>Tagged Image File Format</code><br>，TIFF格式，也叫做或TIF格式，可以支持不同颜色模式、路径、透明度、以及通道，是打印文档中最常用的格式。Photoshop支持在TIFF文件中保存图层以及其他信息，在很多方面类似于PSD格式文件。</p>
<h2 id="bmp"><a href="#bmp" class="headerlink" title="bmp"></a>bmp</h2><p>全称<code>Bitmap</code>。<br>BMP 格式是Windows操作系统中的标准图像文件格式，能够被多种Windows应用程序所支持。BMP格式包含的图像信息较丰富，<strong>几乎不进行压缩</strong>，但由此导致了它占用的存储空间很大，所以，目前BMP在单机上比较流行。</p>
<h2 id="webp"><a href="#webp" class="headerlink" title="webp"></a>webp</h2><p>google开发的一种有损、透明图片格式，相当于jpeg和png的合体，google声称其可以把图片大小减少40%。但是当前支持差，压得慢。</p>
<h2 id="svg"><a href="#svg" class="headerlink" title="svg"></a>svg</h2><p>全称<code>Scalable Vector Graphics</code>，意思为可缩放的矢量图形。它是<strong>基于XML</strong>（Extensible Markup Language），由World Wide Web Consortium（W3C）联盟进行开发的。严格来说应该是一种开放标准的矢量图形语言，可让你设计激动人心的、高分辨率的Web图形页面。用户可以直接用代码来描绘图像，可以用任何文字处理工具打开SVG图像，通过改变部分代码来使图像具有交互功能，并可以随时插入到HTML中通过浏览器来观看。</p>
<p><img src="https://cdn.jsdelivr.net/gh/biggfish3147/pics/blog/ilF0003.jpg" alt="图像啊图像"></p>
<h1 id="图像的附加信息"><a href="#图像的附加信息" class="headerlink" title="图像的附加信息"></a>图像的附加信息</h1><h2 id="Exif信息"><a href="#Exif信息" class="headerlink" title="Exif信息"></a>Exif信息</h2><p>Exif <code>Exchangeable image file format</code>可交换图像文件格式，是<strong>专门为数码相机的照片设定的，可以记录数码照片的属性信息和拍摄数据</strong>。如米6拍摄的照片，照片文件详情中附带有拍摄参数，便是exif信息。Exif可以附加于JPEG、TIFF、RIFF等文件之中，为其增加有关数码相机拍摄信息的内容和索引图或图像处理软件的版本信息。</p>
<p>所有的JPEG文件以字符串“0xFFD8”开头，并以字符串“0xFFD9”结束。文件头中有一系列“0xFF??”格式的字符串，称为“标识”，用来标记JPEG文件的信息段。“0xFFD8”表示图像信息开始，“0xFFD9”表示图像信息结束，这两个标识后面没有信息，而其它标识紧跟一些信息字符。0xFFE0 – 0xFFEF之间的标识符称为“<strong>应用标记</strong>”，没有被常规JPEG文件利用，<strong>Exif正是利用这些信息串记录拍摄信息如快门速度、光圈值等，甚至可以包括全球定位信息。</strong></p>
<h2 id="隐私数据思考"><a href="#隐私数据思考" class="headerlink" title="隐私数据思考"></a>隐私数据思考</h2><p><strong>手机所拍的照片，在查看详情时可能看到地理位置信息，即拍摄地的经纬度坐标信息</strong>。通过经纬度坐标，利用百度的拾取坐标系统进行坐标反查，能够精准定位相片的拍摄地址。这里便思考到隐私数据的问题，如果拍摄的相片都附加这些地址信息，那是不是存在隐私泄露的问题。</p>
<p>于是我尝试将图片原图（包含地址信息）从手机QQ/微信传到电脑QQ/微信，图片另存为，查看图片详情（文件大小未变化），发现图像的拍摄参数及地址信息依旧能看到。进一步，我下载来自朋友圈和QQ动态的实拍图片（自己上传测试用的照片），并查看详细信息，拍摄参数以及地址信息均为空。</p>
<p>那么照片的exif信息是被脱敏了吗？还是我们的exif信息在特定的传输过程被丢弃（蓝牙传输文件exif信息仍存在）？当我们的原图上传到qq空间或朋友圈后，图片的存储位置在腾讯的数据中心，腾讯里的我们的照片已经不包含地址信息了吗？还是图片进一步有损压缩（提高网络传输效率）直接丢弃附属信息？</p>
<p>答案尚且确定不了。但知道一点，<strong>相机设置里可以关闭 保存地理位置信息 的选项</strong>。如此，原图没有位置信息，便不存在地址泄露的隐私问题了。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>大致整理一下，才发现枯燥的文字是真的多。收获就是大概知道web开发过程中为什么logo选择.svg或者.icon格式的矢量图，为什么一亿像素相机的相片用HEIF图片格式（米10高质量图片降低文件大小的解决方案），知道jpeg格式图片改动后保存会导致图片越来越小。</p>
<p>更重要的是知道这样一种观点：<font color="red">无论哪一种图片格式规范，其本质都是为了图像传输的高效或者图像的高质量，两者不可得兼</font>。没得最完美的，适合你需求的就是最好的选择。</p>
<h1 id="参考文献："><a href="#参考文献：" class="headerlink" title="参考文献："></a>参考文献：</h1><p><a href="https://www.coreldrawchina.com/xinshourumen/weitu-shiliangtu.html" target="_blank" rel="noopener">矢量图与位图的区别</a><br><a href="https://www.zhihu.com/question/21283005" target="_blank" rel="noopener">知乎：既然矢量图放大缩小都不失真，为什么还要使用位图？</a><br><a href="https://www.zhihu.com/question/20028452" target="_blank" rel="noopener">图片格式 jpg、png、gif各有什么优缺点？什么情况下用什么格式的图片呢？</a><br><a href="https://zhuanlan.zhihu.com/p/143649897" target="_blank" rel="noopener">几种常见图片格式的区别</a><br><a href="https://blog.csdn.net/jianzhengzhouzjz/article/details/7427432" target="_blank" rel="noopener">像素深度与图像深度</a><br><a href="https://blog.csdn.net/tz_zs/article/details/79768201" target="_blank" rel="noopener">二值图像、灰度图像、彩色图像</a><br><a href="https://juejin.im/post/5c8e4feb6fb9a070aa5ce200" target="_blank" rel="noopener">PNG图片压缩原理解析</a>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/biggfish3147/pics/blog/ilF0013.jpg" alt="图像啊图像"></p>
]]></content>
      <categories>
        <category>常识</category>
      </categories>
      <tags>
        <tag>概念</tag>
        <tag>图像</tag>
        <tag>常识</tag>
      </tags>
  </entry>
  <entry>
    <title>docker通过nginx镜像部署静态文件</title>
    <url>/2020/09/18/docker%E9%80%9A%E8%BF%87nginx%E9%95%9C%E5%83%8F%E9%83%A8%E7%BD%B2%E9%9D%99%E6%80%81%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<p>docker通过nginx镜像部署项目的实质，就是<strong>将（项目）静态文件和及其依赖（nginx）制作成镜像(image)，然后通过镜像生成容器</strong>的过程。这样，通过运行容器就能运行服务，而且image可以方便分享。</p>
<p>准备工作包括：需要部署的静态文件，自定义的nginx配置文件，<strong>Dockerfile文件</strong>（制作镜像）。</p>
<h2 id="1-获得打包后的静态文件"><a href="#1-获得打包后的静态文件" class="headerlink" title="1. 获得打包后的静态文件"></a>1. 获得打包后的静态文件</h2><p>vue项目与react项目的打包方式不一样，基本上执行<code>yarn build</code>类似的指令就可以构建打包，获得<code>dist/</code>目录（内部保存的就是静态文件）。一般而言，开发环境中<code>node_module</code>依赖包特别多，打包过程只有用到的依赖进入了静态文件。所以开发环境中项目可能几个GB，但打包完成的静态文件只占几十MB。</p>
<h2 id="2-准备default-conf文件"><a href="#2-准备default-conf文件" class="headerlink" title="2. 准备default.conf文件"></a>2. 准备default.conf文件</h2><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">===</span> <span class="string">default.conf文件（替换nginx镜像中默认的配置文件）</span> <span class="string">===</span></span><br><span class="line"></span><br><span class="line"><span class="string">server</span> <span class="string">&#123;</span></span><br><span class="line">    <span class="string">listen</span>       <span class="number">3000</span><span class="string">;</span> <span class="string">//项目中的端口号(真实使用#注释)</span></span><br><span class="line">    <span class="string">server_name</span>  <span class="string">localhost;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#charset koi8-r;</span></span><br><span class="line">    <span class="comment">#access_log  /var/log/nginx/log/host.access.log  main;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">location</span> <span class="string">/</span> <span class="string">&#123;</span></span><br><span class="line">        <span class="string">root</span>   <span class="string">/usr/share/nginx/html;</span>   <span class="string">//配置url映射的真实位置</span></span><br><span class="line">        <span class="string">index</span>  <span class="string">index.html</span> <span class="string">index.htm;</span></span><br><span class="line">    <span class="string">&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#error_page  404              /404.html;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># redirect server error pages to the static page /50x.html</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="string">error_page</span>   <span class="number">500</span> <span class="number">502</span> <span class="number">503</span> <span class="number">504</span>  <span class="string">/50x.html;</span></span><br><span class="line">    <span class="string">location</span> <span class="string">=</span> <span class="string">/50x.html</span> <span class="string">&#123;</span></span><br><span class="line">        <span class="string">root</span>   <span class="string">html;</span></span><br><span class="line">    <span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="3-编写Dockerfile文件"><a href="#3-编写Dockerfile文件" class="headerlink" title="3. 编写Dockerfile文件"></a>3. 编写Dockerfile文件</h2><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">===</span> <span class="string">Dockerfile文件</span> <span class="string">===</span></span><br><span class="line"></span><br><span class="line"><span class="string">FROM</span> <span class="attr">nginx:1.14.0</span> <span class="string">//使用Nginx作为基础镜像（从镜像仓库拉取）</span></span><br><span class="line"></span><br><span class="line"><span class="string">MAINTAINER</span> <span class="string">ldj</span> <span class="string">//作者</span></span><br><span class="line"></span><br><span class="line"><span class="string">RUN</span> <span class="string">rm</span> <span class="string">/etc/nginx/conf.d/default.conf</span> <span class="string">//删除nginx</span> <span class="string">默认配置(后边路径说明nginx镜像以linux系统作为基础镜像)</span></span><br><span class="line"></span><br><span class="line"><span class="string">ADD</span> <span class="string">default.conf</span> <span class="string">/etc/nginx/conf.d/</span> <span class="string">//添加我们自己的配置</span> <span class="string">default.conf</span> <span class="string">在下面</span></span><br><span class="line"></span><br><span class="line"><span class="string">COPY</span> <span class="string">dist/</span>  <span class="string">/usr/share/nginx/html/</span>  <span class="string">//把刚才生成dist文件夹下的文件copy到nginx下面去</span></span><br></pre></td></tr></table></figure>

<h2 id="4-创建镜像"><a href="#4-创建镜像" class="headerlink" title="4. 创建镜像"></a>4. 创建镜像</h2><figure class="highlight vala"><table><tr><td class="code"><pre><span class="line"><span class="meta"># 当前文件结构</span></span><br><span class="line"></span><br><span class="line">├── <span class="keyword">default</span>.conf</span><br><span class="line">├── dist</span><br><span class="line">└── Dockerfile</span><br><span class="line"></span><br><span class="line"><span class="meta"># docker打包</span></span><br><span class="line"><span class="meta"># -t指定镜像名称:版本号（tag）</span></span><br><span class="line">docker image build -t biggfish:<span class="number">1.0</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># 生成容器</span></span><br><span class="line"><span class="meta"># 末尾千万不要加 /bin/bash 否则端口不能正常映射</span></span><br><span class="line">docker container run -p <span class="number">3000</span>:<span class="number">3000</span> -itd --name biggfishContainer biggfish:<span class="number">1.0</span></span><br></pre></td></tr></table></figure>

<h2 id="5-访问测试"><a href="#5-访问测试" class="headerlink" title="5. 访问测试"></a>5. 访问测试</h2><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">通过 本机ip:<span class="number">3000</span> 访问</span><br><span class="line"></span><br><span class="line">如果能看到项目首页：成功</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>教程</tag>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>docker常用指令</title>
    <url>/2020/09/18/docker%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/</url>
    <content><![CDATA[<figure class="highlight vala"><table><tr><td class="code"><pre><span class="line"><span class="meta"># 进入容器</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//（run方式）运行容器时在使用 -d 参数时，容器启动后会进入后台</span></span><br><span class="line"><span class="comment">// -it参数：命令提示符效果（i：交互式 t：伪终端）</span></span><br><span class="line"><span class="comment">// /bin/bash 参数表明进入容器后执行的cmd命令（使用shell指令）</span></span><br><span class="line"></span><br><span class="line">docker exec -it 容器id /bin/bash</span><br><span class="line"></span><br><span class="line"><span class="comment">//退出当前容器（exec进入，exit退出时不停止容器；attach进入，停止）</span></span><br><span class="line"></span><br><span class="line">exit</span><br><span class="line"></span><br><span class="line"><span class="meta"># 拉取镜像（从docker hub镜像仓库）</span></span><br><span class="line">docker pull nginx(镜像名称)</span><br><span class="line"></span><br><span class="line"><span class="meta"># 查看镜像 </span></span><br><span class="line">docker images</span><br><span class="line"></span><br><span class="line"><span class="meta"># 创建镜像（提前写好Dockerfile） </span></span><br><span class="line"><span class="comment">// -t 指定构建的镜像名称（target）</span></span><br><span class="line">docker image build -t diyimage:<span class="number">0.0</span><span class="number">.1</span> .</span><br><span class="line"></span><br><span class="line"><span class="meta"># 删除镜像 </span></span><br><span class="line"><span class="comment">// -f参数：force</span></span><br><span class="line">docker image rm 镜像id</span><br><span class="line">docker rmi [-f] 镜像id</span><br><span class="line"></span><br><span class="line"><span class="meta"># 通过镜像生成容器 </span></span><br><span class="line">docker container run -p <span class="number">8000</span>:<span class="number">3000</span> -itd --name 容器名称 image01:<span class="number">0.0</span><span class="number">.1</span> /bin/bash</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">注：</span></span><br><span class="line"><span class="comment">每次run都会新增容器</span></span><br><span class="line"><span class="comment">-p参数：容器的 3000 端口映射到本机的 8000 端口。</span></span><br><span class="line"><span class="comment">-it参数：容器的 Shell 映射到当前的 Shell，然后你在本机窗口输入的命令，就会传入容器。</span></span><br><span class="line"><span class="comment">-p参数：容器生成后，后台运行</span></span><br><span class="line"><span class="comment">--name参数：指定容器的名称（不指定系统随机命名）</span></span><br><span class="line"><span class="comment">image01:0.0.1：image 文件的名字（如果有标签，还需要提供标签，默认是 latest 标签）</span></span><br><span class="line"><span class="comment">/bin/bash：容器启动以后，内部第一个执行的命令。这里是启动 Bash，保证用户可以使用 Shell。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">又注：如果镜像是基于nginx的，则不要写/bin/bash，否则映射出去的端口失效(无法访问)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># 停止/启动容器 </span></span><br><span class="line">docker container kill/stop/start [containID]</span><br><span class="line"></span><br><span class="line"><span class="meta"># 删除容器 </span></span><br><span class="line">docker container rm 容器id</span><br><span class="line"></span><br><span class="line"><span class="meta"># 查看容器 </span></span><br><span class="line">docker container ls</span><br><span class="line">docker container ls -all</span><br><span class="line"></span><br><span class="line">docker ps</span><br><span class="line">docker ps -a</span><br><span class="line"></span><br><span class="line"><span class="meta"># 保存镜像（eg：viewer-镜像名） </span></span><br><span class="line"></span><br><span class="line">docker save viewers-images  -o  /home/ldj/viewers-image.tar</span><br><span class="line"></span><br><span class="line"><span class="meta"># 载入本地镜像 </span></span><br><span class="line"></span><br><span class="line">docker load -i viewers-image.tar</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>命令</tag>
      </tags>
  </entry>
</search>
