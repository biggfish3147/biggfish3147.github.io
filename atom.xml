<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Biggfish</title>
  
  <subtitle>Good good study！！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-11-12T13:46:38.379Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Dongjie</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>数据库的锁</title>
    <link href="http://yoursite.com/2020/11/12/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E9%94%81/"/>
    <id>http://yoursite.com/2020/11/12/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E9%94%81/</id>
    <published>2020-11-12T13:42:10.000Z</published>
    <updated>2020-11-12T13:46:38.379Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>锁是网络数据库中的一个非常重要的概念，当多个用户同时对数据库并发操作时，会带来数据不一致的问题，所以，锁主要用于多用户环境下保证数据库完整性和一致性。</p><p>在数据库中加锁时，除了<strong>可以对不同的资源加锁，还可以使用不同程度的加锁方式</strong>，即锁有多种模式。</p><h1 id="2-乐观锁与悲观锁"><a href="#2-乐观锁与悲观锁" class="headerlink" title="2. 乐观锁与悲观锁"></a>2. 乐观锁与悲观锁</h1><p>从程序员的角度看，分为乐观锁和悲观锁。</p><p><strong>悲观锁</strong>（Pessimistic Lock），顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以，每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block（阻塞），直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁、表锁、读锁和写锁等，都是在做操作之前先上锁。</p><p><strong>乐观锁</strong>（Optimistic Lock），顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以，不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用<strong>版本号、时间戳</strong>等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量，如果数据库提供类似于write_condition机制，其实都是提供的乐观锁。</p><blockquote><p>链接：<a href="https://www.nowcoder.com/questionTerminal/97c7972a55f6459a900a664ee687536f" target="_blank" rel="noopener">https://www.nowcoder.com/questionTerminal/97c7972a55f6459a900a664ee687536f</a>    来源：牛客网</p></blockquote><h1 id="3-具体的锁"><a href="#3-具体的锁" class="headerlink" title="3. 具体的锁"></a>3. 具体的锁</h1><p>表级锁：共享、排他、意向锁</p><p>行级锁：共享、排他、更新锁</p><h2 id="3-1-共享锁"><a href="#3-1-共享锁" class="headerlink" title="3.1 共享锁"></a>3.1 共享锁</h2><p><strong>共享锁也称为S（Share Lock）锁，用于所有的只读数据操作。</strong></p><p>共享锁是非独占的，允许多个并发事务读取其锁定的资源。</p><p>它具有以下性质：<strong>多个事务可封锁一个共享页；任何事务都不能修改该页；通常是该页被读取完毕，S锁立即被释放。</strong></p><p>在SQL Server中，默认情况下，数据被读取后，立即释放共享锁。例如，执行查询语句“SELECT * FROM my_table”时，首先锁定第一页，读取之后，释放对第一页的锁定，然后锁定第二页。这样，就允许在读操作过程中，修改未被锁定的第一页。</p><p>但是，事务隔离级别连接选项设置和SELECT语句中的锁定设置都可以改变SQL Server的这种默认设置。<br>例如，语句“SELECT * FROM my_table HOLDLOCK”就要求在整个查询过程中，保持对表的锁定，直到查询完成才释放锁定。</p><h2 id="3-2-排他锁"><a href="#3-2-排他锁" class="headerlink" title="3.2 排他锁"></a>3.2 排他锁</h2><p><strong>排他锁（Exclusive Lock，也叫X锁）也叫写锁（X）。表示对数据进行写操作。如果一个事务对对象加了排他锁，其他事务就不能再给它加任何锁了。</strong></p><p>排他锁具有以下几点性质：仅允许一个事务封锁此页；其他任何事务必须等到X锁被释放才能对该页进行访问；X锁一直到事务结束才能被释放。</p><p>产生排他锁的SQL语句如下所示：select * from ad_plan for update;</p><h2 id="3-3-更新锁"><a href="#3-3-更新锁" class="headerlink" title="3.3 更新锁"></a>3.3 更新锁</h2><p><strong>更新锁（也叫U锁）在修改操作的初始化阶段用来锁定可能要被修改的资源，这样可以避免使用共享锁造成的死锁现象。</strong></p><p>因为，当使用共享锁时，修改数据的操作分为两步，首先获得一个共享锁，读取数据，然后将共享锁升级为排他锁，然后再执行修改操作。这样，如果有两个或多个事务同时对一个事务申请了共享锁，在修改数据的时候，这些事务都要将共享锁升级为排他锁。这时，这些事务都不会释放共享锁而是一直等待对方释放，这样就造成了死锁。</p><p>如果一个数据在修改前直接申请更新锁，在数据修改的时候再升级为排他锁，就可以避免死锁。</p><p><strong>更新锁</strong>具有以下性质：<strong>用来预定要对此页施加X锁，它允许其他事务读，但不允许再施加U锁或X锁；当被读取的页将要被更新时，则升级为X锁；U锁一直到事务结束时才能被释放。</strong></p><h2 id="3-4-意向锁"><a href="#3-4-意向锁" class="headerlink" title="3.4 意向锁"></a>3.4 意向锁</h2><p><strong>申请意向锁的动作是数据库完成的，就是说，事务A申请一行的行锁的时候，数据库会自动先开始申请表的意向锁，不需要我们程序员使用代码来申请。</strong></p><p>意向锁说明SQL Server有在资源的低层获得共享锁或独占锁的意向。</p><p>例如，表级的共享意向锁说明事务意图将独占锁释放到表中的页或者行。</p><p>意向锁又可以分为共享意向锁、 独占意向锁和共享式独占意向锁。</p><p>共享意向锁说明事务意图在共享意向锁所锁定的低层资源上放置共享锁来读取数据。</p><p>独占意向锁说明事务意图在共享意向锁所锁定 的低层资源上放置独占锁来修改数据。</p><p>共享式独占锁说明事务允许其他事务使用共享锁来读取顶层资源，并意图在该资源低层上放置独占锁。 </p><blockquote><p>参考来源：<a href="https://blog.csdn.net/C_J33/article/details/79487941" target="_blank" rel="noopener">数据库的锁机制及原理</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      共享锁，排他锁，更新锁，意向锁...锁的诞生，只是为了保证数据一致性。
    
    </summary>
    
    
      <category term="MySQL" scheme="http://yoursite.com/categories/MySQL/"/>
    
    
      <category term="数据库" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="锁" scheme="http://yoursite.com/tags/%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>MVCC与Next-key Locks</title>
    <link href="http://yoursite.com/2020/11/12/MVCC%E4%B8%8ENext-key-Locks/"/>
    <id>http://yoursite.com/2020/11/12/MVCC%E4%B8%8ENext-key-Locks/</id>
    <published>2020-11-12T02:50:25.000Z</published>
    <updated>2020-11-12T02:54:39.318Z</updated>
    
    <content type="html"><![CDATA[<p>MYSQL数据库中，事务主要有4种<strong>隔离级别</strong>，分别是<strong>未提交读，提交读，可重复读，可串行化</strong>。</p><p>多版本并发控制（Muti-Version Concurrency Control,MVCC）是MYSQL的InnoDB引擎实现隔离级别的一种具体方式。主要用来解决提交读和可重复读。</p><p>但是单纯的MVCC还不能解决幻读的问题，于是在MVCC基础上加上Next-key Locks，达到可串行化的效果。</p><p>这里只谈简单的理解。</p><h1 id="1-MVCC"><a href="#1-MVCC" class="headerlink" title="1. MVCC"></a>1. MVCC</h1><p>顾名思义，通过<strong>多版本</strong>来实现并发控制。<strong>同一条记录在系统中可以存在多个版本</strong>。</p><p>谈到并发控制，无非就是加锁实现。但加锁过程也会影响性能，这就是一致性与高可用的矛盾。MVCC免去读操作的加锁（非阻塞的读），使开销更低。<strong>写操作必须加锁</strong>。</p><p>MVCC就是想办法少加点锁，通过其他方式保证数据一致性。<strong>MVCC是通过保存数据在某一个时间点快照来实现的。也就是说不管实现时间多长，每个事务看到的数据都是一致的。</strong></p><p>于是不得不提到版本号、快照读与当前读。</p><p>版本号，包括系统版本号与事务版本号。系统版本号是递增的数字，每开始一个新的事务，系统版本号自动增加。<strong>事务版本号就是事务开始时的系统版本号。</strong></p><p>MVCC机制虽然能够让数据可重复读，但读取的数据可能是历史数据。<strong>读取历史数据的方式，称为快照读，而读取数据库最新版本的数据，称为当前读。</strong></p><p>快照读实现了可重复读。自然的也解决了幻读问题（历史数据未变更）。</p><p>对数据修改的操作(update、insert、delete)都是采用当前读的模式。在执行这几个操作时会读取最新的记录，即使是别的事务提交的数据也可以查询到。读取的是最新的数据，需要加锁。<strong>当前读不能解决幻读问题，需要加锁，使用Next-key Lock。</strong></p><h1 id="1-1-隐藏列"><a href="#1-1-隐藏列" class="headerlink" title="1.1 隐藏列"></a>1.1 隐藏列</h1><p>MVCC工作时，在每行记录后边保存两个隐藏列。分别是数据行的创建时间，数据行的删除时间。这里的时间只是一种说法，不代表具体的时间，而是当时的系统版本号。</p><blockquote><p>注：这里表述的删除时间（版本号）不易理解，恰当的说法应该是回滚版本号（回滚指针）。通过该版本号在回滚日志中查询历史数据。</p></blockquote><p><strong>当开始一个新事务时，该事务的版本号肯定会大于当前所有数据行快照的创建版本号。</strong></p><p>隐藏列对客户端来说是不可见的。</p><h1 id="1-2-回滚日志（undo-log）"><a href="#1-2-回滚日志（undo-log）" class="headerlink" title="1.2 回滚日志（undo log）"></a>1.2 回滚日志（undo log）</h1><p><strong>当事务对数据行进行一次更新操作时，会把旧数据行记录在一个叫做undo log的记录中。</strong></p><p>在undo log中除了记录数据行，还会记录下该行数据的对应的创建版本号。并将原来数据行中的回滚指针指向undo log 记录的这行数据。然后再在原来数据表中进行一次更新操作，如果这次更新操作回滚了，那么就可以根据回滚指针去undo log中查找之前的数据进行复原。</p><p>如果后续还有更新操作的话，就会在undo log中和之前的数据行形成一条链表，链表头就是最新的数据，这条链表就叫做<strong>版本链</strong>。</p><p><strong>事务的可见性都是基于undo log来实现的。</strong></p><h1 id="1-3-事务快照（ReadView-可读视图）"><a href="#1-3-事务快照（ReadView-可读视图）" class="headerlink" title="1.3 事务快照（ReadView/可读视图）"></a>1.3 事务快照（ReadView/可读视图）</h1><p>当进行查询操作时，事务会生成一个ReadView，ReadView是一个事务快照，准确来说是当前时间点系统内活跃的事务列表，也就是说<strong>系统内所有未提交的事务，都会记录在这个Readview内</strong>，事务就根据它来判断哪些数据是可见的，哪些是不可见的。</p><p>查询一条数据时，事务会拿到这个ReadView，去到undo log中进行判断。若查询到某一条数据：</p><ul><li>先去查看undo log中的最新数据行，如果数据行的版本号小于ReadView记录的事务版本号最小值，就说明这条数据对当前数据库是可见的，可以直接作为结果集返回</li><li>若数据行版本号大于ReadView记录最大值，说明这条数据是由一个新的事务修改的，对当前事务不可见，那么就顺着版本链继续往下寻找第一条满足条件的</li><li>若数据行版本号在ReadView最小值和最大值之间，那么就需要进行遍历了整个ReadView了，如果数据行版本号等于ReadView的某个值，则说明该行数据仍然处于活跃状态，那么对当前事务不可见</li></ul><h1 id="1-4-提交读与可重复读的实现"><a href="#1-4-提交读与可重复读的实现" class="headerlink" title="1.4 提交读与可重复读的实现"></a>1.4 提交读与可重复读的实现</h1><p><strong>关键在于生成ReadView的时机不同。</strong></p><p><strong>对提交读来说，事务中的每次读操作都会生成一个新的ReadView</strong>，也就是说，如果这期间某个事务提交了，那么它就会从ReadView中移除。这样确保事务每次读操作都能读到相对比较新的数据。</p><p>而<strong>对可重复读来说，事务只有在第一次进行读操作时才会生成一个ReadView</strong>，后续的读操作都会重复使用这个ReadView。也就是说，如果在此期间有其他事务提交了，那么对于可重复读来说也是不可见的，因为对它来说，事务活跃状态在第一次进行读操作时就已经确定下来，后面不会修改了。</p><h1 id="1-5-理解增删改查"><a href="#1-5-理解增删改查" class="headerlink" title="1.5 理解增删改查"></a>1.5 理解增删改查</h1><p><strong>SELECT</strong> </p><p>在SELECT过程中，InnoDB<strong>只查找版本早于当前事务版本的数据行</strong>，这样可以确保事务读取的行要么是在开始事务之前已经存在要么是事务自身插入或者修改过的，在事务开始之后才插入的行，事务不会看到。<br>行的删除版本号要么未定义，要么大于当前事务版本号，这样可以确保事务读取到的行在事务开始之前未被删除，在事务开始之前就已经过期的数据行，该事务也不会看到。</p><p><strong>INSERT</strong></p><p>将当前系统版本号作为数据行快照的创建版本号。</p><p><strong>DELETE</strong>  </p><p>将当前系统版本号作为数据行快照的删除版本号。</p><p><strong>UPDATE</strong></p><p>将当前系统版本号作为更新前的数据行快照的删除版本号，并将当前系统版本号作为更新后的数据行快照的创建版本号。可以理解为先执行 DELETE 后执行 INSERT。</p><h1 id="2-Next-key-Locks"><a href="#2-Next-key-Locks" class="headerlink" title="2. Next-key Locks"></a>2. Next-key Locks</h1><p><strong>Next-key Locks由record locks(记录锁) 和 gap locks(间隙锁)组合而成</strong>，每次锁住的不光是需要使用的数据，还会锁住这些数据附近的数据。</p><p>InnoDB的三种行锁算法：</p><ul><li>Record Lock：单个行记录上的锁。</li><li>Gap Lock：间隙锁，锁定一个范围，但不包括记录本身。GAP锁的目的，是为了防止同一事务的两次当前读，出现幻读的情况。</li><li>Next-Key Lock：1+2，锁定一个范围，并且锁定记录本身。对于行的查询，都是采用该方法，主要目的是解决幻读的问题。</li></ul><h2 id="2-1-Record-Locks"><a href="#2-1-Record-Locks" class="headerlink" title="2.1 Record Locks"></a>2.1 Record Locks</h2><p>锁定一个记录上的索引，而不是记录本身。</p><h2 id="2-2"><a href="#2-2" class="headerlink" title="2.2"></a>2.2</h2><p>锁定索引之间的间隙，但是不包含索引本身。</p><h2 id="2-3"><a href="#2-3" class="headerlink" title="2.3"></a>2.3</h2><p>Next-Key Locks 是 MySQL 的 InnoDB 存储引擎的一种锁实现。</p><p>当查询的索引含有唯一属性的时候，Next-Key Lock 会进行优化，将其降级为Record Lock，即仅锁住索引本身，不是范围。</p><p>它是 Record Locks 和 Gap Locks 的结合，不仅锁定一个记录上的索引，也锁定索引之间的间隙。</p><h1 id="3-参考"><a href="#3-参考" class="headerlink" title="3. 参考"></a>3. 参考</h1><p><a href="https://juejin.im/post/6844903842505555981#heading-13" target="_blank" rel="noopener">聊聊MVCC和Next-key Locks</a></p><p><a href="https://blog.csdn.net/SCUTJAY/article/details/104653599" target="_blank" rel="noopener">MVCC如何实现数据库读已提交和可重复读这两种隔离级别？</a></p>]]></content>
    
    <summary type="html">
    
      MySQL实现提交读与可重复读隔离级别的一种方式
    
    </summary>
    
    
      <category term="MySQL" scheme="http://yoursite.com/categories/MySQL/"/>
    
    
      <category term="数据库" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="MVCC" scheme="http://yoursite.com/tags/MVCC/"/>
    
      <category term="Next-key Lock" scheme="http://yoursite.com/tags/Next-key-Lock/"/>
    
      <category term="隔离级别" scheme="http://yoursite.com/tags/%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/"/>
    
  </entry>
  
  <entry>
    <title>使用Comparator比较器</title>
    <link href="http://yoursite.com/2020/11/10/%E4%BD%BF%E7%94%A8Comparator%E6%AF%94%E8%BE%83%E5%99%A8/"/>
    <id>http://yoursite.com/2020/11/10/%E4%BD%BF%E7%94%A8Comparator%E6%AF%94%E8%BE%83%E5%99%A8/</id>
    <published>2020-11-10T03:02:19.000Z</published>
    <updated>2020-11-10T03:15:55.077Z</updated>
    
    <content type="html"><![CDATA[<p>数组的排序方式有很多。</p><p>排序，必须选择一个排序标准，可以按照元素的值（整型数组），或者元素的某个属性值（元素为对象时）。</p><p><strong>Arrays工具类，位于java.util包，提供了sort方法。支持自定义比较器，实现升序、降序排列等。</strong></p><p>多维数组，可以看作元素是数组的集合。同样的思想，按照元素的某一个属性，比如元素的某一列值（二维数组）排序。</p><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">ComparatorOrder</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> static <span class="built_in">void</span> main(String[] args) &#123;</span><br><span class="line">        Integer[] nums = new Integer[]&#123;<span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">2</span>&#125;;</span><br><span class="line">        Arrays.sort(nums, (o1, o2) -&gt; o2-o1);</span><br><span class="line">        <span class="comment">//降序，输出：[6,4,3,2,2,1]</span></span><br><span class="line">        System.<span class="keyword">out</span>.println(Arrays.toString(nums));</span><br><span class="line"></span><br><span class="line">        <span class="built_in">int</span>[][] nums2=new <span class="built_in">int</span>[][]&#123;&#123;<span class="number">7</span>,<span class="number">0</span>&#125;,&#123;<span class="number">4</span>,<span class="number">1</span>&#125;,&#123;<span class="number">5</span>,<span class="number">2</span>&#125;,&#123;<span class="number">6</span>,<span class="number">3</span>&#125;,&#123;<span class="number">8</span>,<span class="number">6</span>&#125;&#125;;</span><br><span class="line"><span class="comment">//        Arrays.sort(nums2, new Comparator&lt;int[]&gt;() &#123;</span></span><br><span class="line"><span class="comment">//            @Override</span></span><br><span class="line"><span class="comment">//            public int compare(int[] o1, int[] o2) &#123;</span></span><br><span class="line"><span class="comment">//                return o1[1]-o2[1];</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;);</span></span><br><span class="line">        Arrays.sort(nums2,((o1, o2) -&gt; o1[<span class="number">1</span>]-o2[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//二维数组，按第二列升序</span></span><br><span class="line">        <span class="comment">//输出：</span></span><br><span class="line">        <span class="comment">//[7,0]</span></span><br><span class="line">        <span class="comment">//[4,1]</span></span><br><span class="line">        <span class="comment">//[5,2]</span></span><br><span class="line">        <span class="comment">//[6,3]</span></span><br><span class="line">        <span class="comment">//[8,6]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span>[] n:nums2)&#123;</span><br><span class="line">            System.<span class="keyword">out</span>.println(Arrays.toString(n));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写这个是因为，对compare方法的参数顺序有点懵。所以写下来，理一理。</p><p>o1与o2只是参数名称。</p><p><strong>（o1,o2）-&gt; o1-o2 ，这种形式，代表升序。</strong></p><p>o1代表当前元素，o2是前一个元素。返回o1-o2，默认为正值，表示o1大于o2，即当前元素大于前一个元素。是对数组进行升序排列。</p><p>测试过程中，发现对int[ ] 类型的一维数组，不能使用传入自定义的比较器来进行降序排列。</p><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span>[] nums = new <span class="built_in">int</span>[]&#123;<span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">2</span>&#125;;</span><br><span class="line">Arrays.sort(nums, (o1, o2) -&gt; o2-o1);</span><br></pre></td></tr></table></figure><p>上述的写法会报错（可检查）。<code>操作符-不能被应用到T</code>，即说明自定义比较器中<strong>两个用于比较的元素必须是对象，或者说是引用类型。</strong></p><p>改为如下写法，则编译运行正常。</p><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span>[] nums = <span class="built_in">new</span> <span class="type">Integer</span>[]&#123;<span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">2</span>&#125;;</span><br><span class="line"> </span><br><span class="line">Arrays.sort(nums, <span class="built_in">new</span> Comparator&lt;<span class="type">Integer</span>&gt;()&#123;</span><br><span class="line">    @Override</span><br><span class="line">    <span class="built_in">public</span> <span class="type">int</span> compare(<span class="type">Integer</span> o1, <span class="type">Integer</span> o2) &#123;</span><br><span class="line">        <span class="keyword">return</span> o1-o2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      重写compare方法，怎么实现升序与降序？
    
    </summary>
    
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="排序" scheme="http://yoursite.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>阿里云宝塔面板部署java项目</title>
    <link href="http://yoursite.com/2020/10/30/%E9%98%BF%E9%87%8C%E4%BA%91%E5%AE%9D%E5%A1%94%E9%9D%A2%E6%9D%BF%E9%83%A8%E7%BD%B2java%E9%A1%B9%E7%9B%AE/"/>
    <id>http://yoursite.com/2020/10/30/%E9%98%BF%E9%87%8C%E4%BA%91%E5%AE%9D%E5%A1%94%E9%9D%A2%E6%9D%BF%E9%83%A8%E7%BD%B2java%E9%A1%B9%E7%9B%AE/</id>
    <published>2020-10-30T13:33:37.000Z</published>
    <updated>2020-10-30T13:35:59.706Z</updated>
    
    <content type="html"><![CDATA[<p>背景故事是这样的。</p><p>一个老项目，“上级”指示需要再次启用。</p><p>阿里云实例一周前过期的，如果续费的话，后端代码不用改，前端的请求ip也不用改。原有的java环境就能支持老项目跑起来。</p><p>不要问为什么代码里边不用域名表示主机（映射关系）。如果用域名的话，只需要改一下域名与ip的映射记录就行。这个法儿我是现在才想到的。</p><p>然后就是需要重新租用一个云服务器，配置java运行环境，再把项目扔上去跑（用的是war包）。</p><p>9.5块钱/月的阿里云学生机，选择的是轻量应用服务器，宝塔面板应用镜像。</p><p>宝塔面板一键配置环境真的是“傻瓜”操作，真香。</p><h1 id="1-镜像的理解"><a href="#1-镜像的理解" class="headerlink" title="1. 镜像的理解"></a>1. 镜像的理解</h1><p>任何镜像都是基于系统镜像制作的。</p><p>宝塔面板应用镜像就是在系统镜像的基础上，配置好宝塔面板，然后生成的镜像。</p><p>镜像流行的原因，其中一个原因就是简化配置。特别是运行环境的配置。</p><p>纯净的操作系统镜像，还需要我们自己部署java web运行环境，比如下载tomcat、jdk、mysql等。如果是java运行环境镜像，其内已经装好了相关软件，我们只要知道如何使用即可。</p><p>宝塔面板，顾名思义，就是一个面板控制工具。通过Web页面，即可控制远端服务器的服务开闭、端口开放、项目部署等。</p><h1 id="2-云服务器宝塔面板"><a href="#2-云服务器宝塔面板" class="headerlink" title="2. 云服务器宝塔面板"></a>2. 云服务器宝塔面板</h1><p>一般而言，选购云服务器时需要配置基本参数，其中一项就是<strong>镜像</strong>。</p><p>可以选择纯净的系统镜像，也可以去镜像市场选择免费的定制化镜像使用。</p><p>如果选择宝塔控制面板，即镜像内已经安装并配置好了宝塔面板，那么由该镜像最后生成的实例，就可以直接使用宝塔面板了。</p><p>相当于，别人配好环境，我拿到后开箱即用。</p><h1 id="3-云服务器控制台"><a href="#3-云服务器控制台" class="headerlink" title="3. 云服务器控制台"></a>3. 云服务器控制台</h1><p>宝塔面板是一个控制中心，云服务器（或者轻量应用服务器）也是一个控制中心。云服务器作为上游控制中心，除了对服务器实例的必要运维监控外，还决定着服务器对外开放的端口。</p><p>当然，如果云服务器安装有宝塔面板的话，需要开放TCP 8888端口供外部连接。而且，要进入宝塔面板，需要的账户与密码，也可以在云服务器的控制台进行设置。</p><h1 id="4-宝塔控制面板"><a href="#4-宝塔控制面板" class="headerlink" title="4. 宝塔控制面板"></a>4. 宝塔控制面板</h1><p>如果选择宝塔面板，那么大多数与服务器的交互都变得简洁直观（可视化）。</p><p>云服务器控制台的作用大多数时候就是放行端口（服务器防火墙）。</p><blockquote><p>宝塔控制面板也能对端口放行。但是如果云服务器不放行，在宝塔面板设置放行其实是无效的。大概就是上下游两道闸门的关系。</p></blockquote><p>在宝塔面板，你可以以安装软件的形式（软件商店）来配置环境。这区别于远程登录云服务器，并在终端输入shell命令。面板的操作对新人更加友好，但也相对没有技术含量，不能学到服务器内部的知识。</p><h1 id="5-部署java-web项目"><a href="#5-部署java-web项目" class="headerlink" title="5. 部署java web项目"></a>5. 部署java web项目</h1><p>基本上都是与宝塔控制面板进行交互。</p><ul><li>配置环境</li><li>导入war包</li><li>放行端口</li><li>启动tomcat</li></ul><p>虽然java环境需要jdk，但是在宝塔面板上配置tomcat时，会自动下载jdk。</p><p>导入的war包直接放入到tomcat文件的webapps目录下即可，tomcat会自动解压。</p><h1 id="6-参考"><a href="#6-参考" class="headerlink" title="6. 参考"></a>6. 参考</h1><p><a href="https://my.oschina.net/u/4340796/blog/4315488" target="_blank" rel="noopener">阿里云宝塔面板配置及部署Java项目</a></p><p><a href="https://developer.aliyun.com/article/761633" target="_blank" rel="noopener">阿里云轻量应用服务器应用镜像和系统镜像选择详细介绍</a></p>]]></content>
    
    <summary type="html">
    
      宝塔面板，“傻瓜式”操作真香！
    
    </summary>
    
    
      <category term="教程" scheme="http://yoursite.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="宝塔面板" scheme="http://yoursite.com/tags/%E5%AE%9D%E5%A1%94%E9%9D%A2%E6%9D%BF/"/>
    
  </entry>
  
  <entry>
    <title>二叉树的遍历</title>
    <link href="http://yoursite.com/2020/10/30/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/"/>
    <id>http://yoursite.com/2020/10/30/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/</id>
    <published>2020-10-30T08:58:03.000Z</published>
    <updated>2020-10-30T09:02:58.429Z</updated>
    
    <content type="html"><![CDATA[<p>二叉树的遍历主要分为<strong>深度优先遍历</strong>(dfs)和<strong>广度优先遍历</strong>(bfs)。</p><p>深度优先遍历包括前序遍历、中序遍历和后序遍历，这三种遍历方式都有<strong>递归</strong>和<strong>迭代</strong>两种实现方式。</p><p>广度优先遍历也就是通常我们所说的层次遍历，通常用迭代方式实现。</p><p>前序、中序与后序都是从根节点的视角描述的，前序遍历顺序是<code>根节点——左子树——右子树</code>，中序是<code>左子树——根节点——右子树</code>，后序是<code>左子树——右子树——根节点</code>。</p><p>树的定义本身就是递归定义，所以采用递归方式实现树的前序、中序、后序遍历容易理解且代码简洁。方法的调用栈会保证树的完全遍历。</p><p>而通过非递归的方式实现遍历，则需要借助其他的数据结构，比如栈、队列、堆等。</p><p>递归和迭代本质上都是循环。</p><p>递归存在着方法调用方法自身。迭代暗示着循环的某次计算结果（输出）会作为下一次循环计算的参数（输入）。</p><h1 id="1-深度优先遍历"><a href="#1-深度优先遍历" class="headerlink" title="1. 深度优先遍历"></a>1. 深度优先遍历</h1><p>节点定义。</p><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">TreeNode</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> val;</span><br><span class="line"><span class="keyword">public</span> TreeNode left;</span><br><span class="line"><span class="keyword">public</span> TreeNode right;</span><br><span class="line"><span class="keyword">public</span> TreeNode(<span class="built_in">int</span> v)&#123;</span><br><span class="line"><span class="keyword">this</span>.val=v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-1-前序遍历"><a href="#1-1-前序遍历" class="headerlink" title="1.1 前序遍历"></a>1.1 前序遍历</h2><p>递归方式实现。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrderTraversal</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">        System.out.print(root.val+<span class="string">" "</span>);</span><br><span class="line">        preOrderTraversal(root.left);</span><br><span class="line">        preOrderTraversal(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>迭代方式实现。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//利用 栈 模拟 递归过程 实现循环前序遍历二叉树</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nonrecursivePreOrderTraversal</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">   <span class="keyword">while</span>(root != <span class="keyword">null</span> || !stack.isEmpty())&#123;</span><br><span class="line">       <span class="keyword">while</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">           System.out.print(root.val+<span class="string">" "</span>);</span><br><span class="line">           stack.push(root); <span class="comment">//先访问，再入栈</span></span><br><span class="line">           </span><br><span class="line">           root=root.left;</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">if</span>(!stack.isEmpty())&#123;</span><br><span class="line">            TreeNode root = stack.pop();    <span class="comment">//出栈，并处理右子树</span></span><br><span class="line">            root=root.right;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-2-中序遍历"><a href="#1-2-中序遍历" class="headerlink" title="1.2 中序遍历"></a>1.2 中序遍历</h2><p>递归方式实现。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inOrderTraversal</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">        inOrderTraversal(root.left);</span><br><span class="line">        System.out.print(root.val+<span class="string">" "</span>);</span><br><span class="line">        inOrderTraversal(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>迭代方式实现。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nonrecursiveInOrderTraversal</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>( root != <span class="keyword">null</span> || !stack.isEmpty())&#123;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">while</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">          stack.push(root);</span><br><span class="line">          root = root.left;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(!stack.isEmpty())&#123;</span><br><span class="line">            TreeNode root=stack.pop();  <span class="comment">//出栈</span></span><br><span class="line">            System.out.print(root.val+<span class="string">" "</span>);</span><br><span class="line">            root=root.right;    <span class="comment">//处理右子树</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-3-后序遍历"><a href="#1-3-后序遍历" class="headerlink" title="1.3 后序遍历"></a>1.3 后序遍历</h2><p>递归方式实现。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postOrderTraversal</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">        postOrderTraversal(root.left);</span><br><span class="line">        postOrderTraversal(root.right);</span><br><span class="line">        System.out.print(root.val+<span class="string">" "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>迭代方式实现。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//后序遍历与前、中序遍历不太一样</span></span><br><span class="line"><span class="comment">//当前节点是否打印：它的右子树为 null ,或者它的右子树已经被访问了（游标标识）</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nonrecursivePostOrderTraversal</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="keyword">null</span>) &#123;<span class="keyword">return</span>;&#125;</span><br><span class="line">    </span><br><span class="line">    Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    TreeNode node = root; <span class="comment">//替换，使用node变量</span></span><br><span class="line">    TreeNode lastVisit = root;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(node != <span class="keyword">null</span> || !stack.isEmpty())&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(node != <span class="keyword">null</span>)&#123;</span><br><span class="line">            stack.push(node);</span><br><span class="line">            node=node.left;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        node=stack.peek();  <span class="comment">//查看当前栈顶元素</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(node.right == <span class="keyword">null</span> || node.right==lastVisit)&#123;  <span class="comment">//如果当前节点右子树为空或者右子树已经被访问</span></span><br><span class="line">            System.out.print(node.val+<span class="string">" "</span>);</span><br><span class="line">            stack.pop();</span><br><span class="line">            lastVisit=node;</span><br><span class="line">            node=<span class="keyword">null</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;  <span class="comment">//否则，继续遍历右子树（保证遍历完全部节点）</span></span><br><span class="line">            node=node.right;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-广度优先遍历-层次遍历"><a href="#2-广度优先遍历-层次遍历" class="headerlink" title="2. 广度优先遍历(层次遍历)"></a>2. 广度优先遍历(层次遍历)</h1><p>通过迭代方式实现。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">levelTraversal</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Queue&lt;TreeNode&gt; queue=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    queue.add(root);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">        TreeNode node=queue.remove();</span><br><span class="line">        System.out.print(node.val+<span class="string">" "</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(node.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">            queue.add(node.left);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(node.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">            queue.add(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里可以对照着广度优先遍历的代码形式，重新描述一下深度优先遍历（非递归实现前序遍历）。</p><p>下述这种遍历方式不具备扩展性，类似于图的深度优先遍历（DFS）。这种方式应该是对先序遍历的一种特殊实现，思路清晰明了，在中序和后序方式中不适用。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depthOrderTraversal</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Deque&lt;TreeNode&gt; stack=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    stack.push(root);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">        </span><br><span class="line">        TreeNode node=stack.pop();</span><br><span class="line">        System.out.print(node.val+<span class="string">" "</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(node.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">            stack.push(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(node.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">            stack.push(node.left);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-参考资料"><a href="#3-参考资料" class="headerlink" title="3. 参考资料"></a>3. 参考资料</h1><p><a href="https://www.jianshu.com/p/456af5480cee" target="_blank" rel="noopener">二叉树遍历(先序、中序、后序)</a></p><p><a href="https://blog.csdn.net/kerryfish/article/details/24309617" target="_blank" rel="noopener">JAVA下实现二叉树的先序、中序、后序、层序遍历（递归和循环）</a></p>]]></content>
    
    <summary type="html">
    
      二叉树的知识，遍历方法是基石 ！
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Java浅拷贝和深拷贝</title>
    <link href="http://yoursite.com/2020/10/17/Java%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D/"/>
    <id>http://yoursite.com/2020/10/17/Java%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D/</id>
    <published>2020-10-17T05:39:53.000Z</published>
    <updated>2020-10-17T05:49:20.095Z</updated>
    
    <content type="html"><![CDATA[<p>本文转载自简书（安静的蓝孩子）<a href="https://www.jianshu.com/p/94dbef2de298" target="_blank" rel="noopener">Java浅拷贝和深拷贝</a></p><blockquote><p>作者：安静的蓝孩子 链接：<a href="https://www.jianshu.com/p/94dbef2de298" target="_blank" rel="noopener">https://www.jianshu.com/p/94dbef2de298</a>  来源：简书</p></blockquote><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>开发过程中，有时会遇到把现有的一个对象的所有成员属性拷贝给另一个对象的需求。<br>比如说对象 A 和对象 B，二者都是 ClassC 的对象，具有成员变量 a 和 b，现在对对象 A 进行拷贝赋值给 B，也就是 B.a = A.a; B.b = A.b;</p><p>这时再去改变 B 的属性 a 或者 b 时，可能会遇到问题：假设 a 是基础数据类型，b 是引用类型。<br>当改变 B.a 的值时，没有问题；<br>当改变 B.b 的值时，同时也会改变 A.b 的值，因为其实上面的例子中只是把 A.b 赋值给了 B.b，因为是 b 引用类型的，所以它们是指向同一个地址的。这可能就会给我们使用埋下隐患。</p><blockquote><p>Java 中的数据类型分为基本数据类型和引用数据类型。对于这两种数据类型，在进行赋值操作、用作方法参数或返回值时，会有值传递和引用（地址）传递的差别。</p></blockquote><h1 id="拷贝分类"><a href="#拷贝分类" class="headerlink" title="拷贝分类"></a>拷贝分类</h1><p>上面的问题，其实就是因为对拷贝的不熟悉导致的。</p><p>根据对对象属性的拷贝程度（基本数据类和引用类型），会分为两种：</p><ul><li>浅拷贝 (<code>Shallow Copy</code>)</li><li>深拷贝 (<code>Deep Copy</code>)</li></ul><h1 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h1><h2 id="1-浅拷贝介绍"><a href="#1-浅拷贝介绍" class="headerlink" title="1. 浅拷贝介绍"></a>1. 浅拷贝介绍</h2><p>浅拷贝是按位拷贝对象，它会创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值；如果属性是内存地址（引用类型），拷贝的就是内存地址 ，因此如果其中一个对象改变了这个地址，就会影响到另一个对象。即默认拷贝构造函数只是对对象进行浅拷贝复制(逐个成员依次拷贝)，即只复制对象空间而不复制资源。</p><h2 id="2-浅拷贝特点"><a href="#2-浅拷贝特点" class="headerlink" title="2. 浅拷贝特点"></a>2. 浅拷贝特点</h2><p>(1) 对于基本数据类型的成员对象，因为基础数据类型是值传递的，所以是直接将属性值赋值给新的对象。基础类型的拷贝，其中一个对象修改该值，不会影响另外一个。<br>(2) 对于引用类型，比如数组或者类对象，因为引用类型是引用传递，所以浅拷贝只是把内存地址赋值给了成员变量，它们指向了同一内存空间。改变其中一个，会对另外一个也产生影响。</p><p>结构图如下：</p><p><img src="https://cdn.jsdelivr.net/gh/biggfish3147/pics/note/shallowClone.png" alt="浅拷贝"></p><h2 id="3-浅拷贝的实现"><a href="#3-浅拷贝的实现" class="headerlink" title="3. 浅拷贝的实现"></a>3. 浅拷贝的实现</h2><p>实现对象拷贝的类，需要实现 <code>Cloneable</code> 接口，并覆写 <code>clone()</code> 方法。</p><p>示例如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Subject</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"[Subject: "</span> + <span class="keyword">this</span>.hashCode() + <span class="string">",name:"</span> + name + <span class="string">"]"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//引用类型</span></span><br><span class="line">    <span class="keyword">private</span> Subject subject;</span><br><span class="line">    <span class="comment">//基础数据类型</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function">Subject <span class="title">getSubject</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> subject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">setSubject</span><span class="params">(Subject subject)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.subject = subject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function">String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  重写clone()方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function">Object <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//浅拷贝</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 直接调用父类的clone()方法</span></span><br><span class="line">            <span class="function"><span class="keyword">return</span> <span class="keyword">super</span>.<span class="title">clone</span><span class="params">()</span></span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function">String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"[Student: "</span> + <span class="keyword">this</span>.hashCode() + <span class="string">",subject:"</span> + subject + <span class="string">",name:"</span> + name + <span class="string">",age:"</span> + age + <span class="string">"]"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">public <span class="keyword">class</span> ShallowCopy &#123;</span><br><span class="line">    public static void main(String<span class="literal">[]</span> args) &#123;</span><br><span class="line">        Subject subject = <span class="keyword">new</span> <span class="constructor">Subject(<span class="string">"yuwen"</span>)</span>;</span><br><span class="line">        Student studentA = <span class="keyword">new</span> <span class="constructor">Student()</span>;</span><br><span class="line">        studentA.set<span class="constructor">Subject(<span class="params">subject</span>)</span>;</span><br><span class="line">        studentA.set<span class="constructor">Name(<span class="string">"Lynn"</span>)</span>;</span><br><span class="line">        studentA.set<span class="constructor">Age(20)</span>;</span><br><span class="line">        Student studentB = (Student) studentA.clone<span class="literal">()</span>;</span><br><span class="line">        studentB.set<span class="constructor">Name(<span class="string">"Lily"</span>)</span>;</span><br><span class="line">        studentB.set<span class="constructor">Age(18)</span>;</span><br><span class="line">        Subject subjectB = studentB.get<span class="constructor">Subject()</span>;</span><br><span class="line">        subjectB.set<span class="constructor">Name(<span class="string">"lishi"</span>)</span>;</span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">"studentA:"</span> + studentA.<span class="keyword">to</span><span class="constructor">String()</span>);</span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">"studentB:"</span> + studentB.<span class="keyword">to</span><span class="constructor">String()</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出的结果：</p><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="string">studentA:</span>[<span class="string">Student:</span> <span class="number">460141958</span>,<span class="string">subject:</span>[<span class="string">Subject:</span> <span class="number">1163157884</span>,<span class="string">name:</span>lishi],<span class="string">name:</span>Lynn,<span class="string">age:</span><span class="number">20</span>]</span><br><span class="line"><span class="string">studentB:</span>[<span class="string">Student:</span> <span class="number">1956725890</span>,<span class="string">subject:</span>[<span class="string">Subject:</span> <span class="number">1163157884</span>,<span class="string">name:</span>lishi],<span class="string">name:</span>Lily,<span class="string">age:</span><span class="number">18</span>]</span><br></pre></td></tr></table></figure><p>由输出的结果可见，通过 <code>studentA.clone()</code> 拷贝对象后得到的 <code>studentB</code>，和 <code>studentA</code> 是两个不同的对象。<code>studentA</code> 和 <code>studentB</code> 的基础数据类型的修改互不影响，而引用类型 <code>subject</code> 修改后是会有影响的。</p><h2 id="浅拷贝和对象拷贝的区别："><a href="#浅拷贝和对象拷贝的区别：" class="headerlink" title="浅拷贝和对象拷贝的区别："></a>浅拷贝和对象拷贝的区别：</h2><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">public static void main(String<span class="literal">[]</span> args) &#123;</span><br><span class="line">        Subject subject = <span class="keyword">new</span> <span class="constructor">Subject(<span class="string">"yuwen"</span>)</span>;</span><br><span class="line">        Student studentA = <span class="keyword">new</span> <span class="constructor">Student()</span>;</span><br><span class="line">        studentA.set<span class="constructor">Subject(<span class="params">subject</span>)</span>;</span><br><span class="line">        studentA.set<span class="constructor">Name(<span class="string">"Lynn"</span>)</span>;</span><br><span class="line">        studentA.set<span class="constructor">Age(20)</span>;</span><br><span class="line">        Student studentB = studentA;</span><br><span class="line">        studentB.set<span class="constructor">Name(<span class="string">"Lily"</span>)</span>;</span><br><span class="line">        studentB.set<span class="constructor">Age(18)</span>;</span><br><span class="line">        Subject subjectB = studentB.get<span class="constructor">Subject()</span>;</span><br><span class="line">        subjectB.set<span class="constructor">Name(<span class="string">"lishi"</span>)</span>;</span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">"studentA:"</span> + studentA.<span class="keyword">to</span><span class="constructor">String()</span>);</span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">"studentB:"</span> + studentB.<span class="keyword">to</span><span class="constructor">String()</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里把 <code>Student studentB = (Student) studentA.clone()</code> 换成了 <code>Student studentB = studentA</code>。<br>输出的结果：</p><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="string">studentA:</span>[<span class="string">Student:</span> <span class="number">460141958</span>,<span class="string">subject:</span>[<span class="string">Subject:</span> <span class="number">1163157884</span>,<span class="string">name:</span>lishi],<span class="string">name:</span>Lily,<span class="string">age:</span><span class="number">18</span>]</span><br><span class="line"><span class="string">studentB:</span>[<span class="string">Student:</span> <span class="number">460141958</span>,<span class="string">subject:</span>[<span class="string">Subject:</span> <span class="number">1163157884</span>,<span class="string">name:</span>lishi],<span class="string">name:</span>Lily,<span class="string">age:</span><span class="number">18</span>]</span><br></pre></td></tr></table></figure><p>可见，对象拷贝后没有生成新的对象，二者的对象地址是一样的；而浅拷贝的对象地址是不一样的。</p><h1 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h1><h2 id="1-深拷贝介绍"><a href="#1-深拷贝介绍" class="headerlink" title="1. 深拷贝介绍"></a>1. 深拷贝介绍</h2><p>通过上面的例子可以看到，浅拷贝会带来数据安全方面的隐患，例如我们只是想修改了 studentB 的 subject，但是 studentA 的 subject 也被修改了，因为它们都是指向的同一个地址。所以，此种情况下，我们需要用到深拷贝。</p><p>深拷贝，在拷贝引用类型成员变量时，为引用类型的数据成员另辟了一个独立的内存空间，实现真正内容上的拷贝。</p><h2 id="2-深拷贝特点"><a href="#2-深拷贝特点" class="headerlink" title="2. 深拷贝特点"></a>2. 深拷贝特点</h2><p>(1) 对于基本数据类型的成员对象，因为基础数据类型是值传递的，所以是直接将属性值赋值给新的对象。基础类型的拷贝，其中一个对象修改该值，不会影响另外一个（和浅拷贝一样）。<br>(2) 对于引用类型，比如数组或者类对象，深拷贝会新建一个对象空间，然后拷贝里面的内容，所以它们指向了不同的内存空间。改变其中一个，不会对另外一个也产生影响。<br>(3) 对于有多层对象的，每个对象都需要实现 <code>Cloneable</code> 并重写 <code>clone()</code> 方法，进而实现了对象的串行层层拷贝。<br>(4) 深拷贝相比于浅拷贝速度较慢并且花销较大。</p><p>结构图如下：<br><img src="https://cdn.jsdelivr.net/gh/biggfish3147/pics/note/deepClone.png" alt="深拷贝"></p><h2 id="3-深拷贝的实现"><a href="#3-深拷贝的实现" class="headerlink" title="3. 深拷贝的实现"></a>3. 深拷贝的实现</h2><p>对于 <code>Student</code> 的引用类型的成员变量 <code>Subject</code> ，需要实现 <code>Cloneable</code> 并重写 <code>clone()</code> 方法。</p><figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Subject</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Subject</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function">String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="function">Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="comment">//Subject 如果也有引用类型的成员属性，也应该和 Student 类一样实现</span></span><br><span class="line">        <span class="function"><span class="keyword">return</span> <span class="keyword">super</span>.<span class="title">clone</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function">String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"[Subject: "</span> + <span class="keyword">this</span>.hashCode() + <span class="string">",name:"</span> + name + <span class="string">"]"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>Student</code> 的 <code>clone()</code> 方法中，需要拿到拷贝自己后产生的新的对象，然后对新的对象的引用类型再调用拷贝操作，实现对引用类型成员变量的深拷贝。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//引用类型</span></span><br><span class="line">    <span class="keyword">private</span> Subject subject;</span><br><span class="line">    <span class="comment">//基础数据类型</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Subject <span class="title">getSubject</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> subject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSubject</span><span class="params">(Subject subject)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.subject = subject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  重写clone()方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//深拷贝</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 直接调用父类的clone()方法</span></span><br><span class="line">            Student student = (Student) <span class="keyword">super</span>.clone();</span><br><span class="line">            student.subject = (Subject) subject.clone();</span><br><span class="line">            <span class="keyword">return</span> student;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"[Student: "</span> + <span class="keyword">this</span>.hashCode() + <span class="string">",subject:"</span> + subject + <span class="string">",name:"</span> + name + <span class="string">",age:"</span> + age + <span class="string">"]"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一样的使用方式</p><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">public <span class="keyword">class</span> ShallowCopy &#123;</span><br><span class="line">    public static void main(String<span class="literal">[]</span> args) &#123;</span><br><span class="line">        Subject subject = <span class="keyword">new</span> <span class="constructor">Subject(<span class="string">"yuwen"</span>)</span>;</span><br><span class="line">        Student studentA = <span class="keyword">new</span> <span class="constructor">Student()</span>;</span><br><span class="line">        studentA.set<span class="constructor">Subject(<span class="params">subject</span>)</span>;</span><br><span class="line">        studentA.set<span class="constructor">Name(<span class="string">"Lynn"</span>)</span>;</span><br><span class="line">        studentA.set<span class="constructor">Age(20)</span>;</span><br><span class="line">        Student studentB = (Student) studentA.clone<span class="literal">()</span>;</span><br><span class="line">        studentB.set<span class="constructor">Name(<span class="string">"Lily"</span>)</span>;</span><br><span class="line">        studentB.set<span class="constructor">Age(18)</span>;</span><br><span class="line">        Subject subjectB = studentB.get<span class="constructor">Subject()</span>;</span><br><span class="line">        subjectB.set<span class="constructor">Name(<span class="string">"lishi"</span>)</span>;</span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">"studentA:"</span> + studentA.<span class="keyword">to</span><span class="constructor">String()</span>);</span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">"studentB:"</span> + studentB.<span class="keyword">to</span><span class="constructor">String()</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="attribute">studentA</span>:[<span class="attribute">Student</span>: <span class="number">460141958</span>,<span class="attribute">subject</span>:[<span class="attribute">Subject</span>: <span class="number">1163157884</span>,<span class="attribute">name</span>:yuwen],<span class="attribute">name</span>:Lynn,<span class="attribute">age</span>:<span class="number">20</span>]</span><br><span class="line"><span class="attribute">studentB</span>:[<span class="attribute">Student</span>: <span class="number">1956725890</span>,<span class="attribute">subject</span>:[<span class="attribute">Subject</span>: <span class="number">356573597</span>,<span class="attribute">name</span>:lishi],<span class="attribute">name</span>:Lily,<span class="attribute">age</span>:<span class="number">18</span>]</span><br></pre></td></tr></table></figure><p>由输出结果可见，深拷贝后，不管是基础数据类型还是引用类型的成员变量，修改其值都不会相互造成影响。</p><p>参考：</p><p><a href="https://www.cnblogs.com/shakinghead/p/7651502.html" target="_blank" rel="noopener">Java 浅拷贝和深拷贝的理解和实现方式</a><br><a href="https://blog.csdn.net/u014727260/article/details/55003402" target="_blank" rel="noopener">浅拷贝和深拷贝(谈谈java中的clone)</a></p>]]></content>
    
    <summary type="html">
    
      深拷贝与浅拷贝，都不同于对象拷贝 ！
    
    </summary>
    
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="拷贝" scheme="http://yoursite.com/tags/%E6%8B%B7%E8%B4%9D/"/>
    
  </entry>
  
  <entry>
    <title>对象的序列化：Serializable接口</title>
    <link href="http://yoursite.com/2020/10/12/%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%9ASerializable%E6%8E%A5%E5%8F%A3/"/>
    <id>http://yoursite.com/2020/10/12/%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%9ASerializable%E6%8E%A5%E5%8F%A3/</id>
    <published>2020-10-12T05:34:11.000Z</published>
    <updated>2020-10-12T05:39:08.365Z</updated>
    
    <content type="html"><![CDATA[<p>一般而言，定义实体类时会实现 <code>Serializable</code>接口，同时还要显示指定<code>serialVersionUID</code>的值。</p><p>为什么要有这些操作呢？这里就试图简单理解。</p><h1 id="1-序列化与反序列化"><a href="#1-序列化与反序列化" class="headerlink" title="1. 序列化与反序列化"></a>1. 序列化与反序列化</h1><p><font color="red">序列化</font>：把对象转换为字节序列的过程称为对象的序列化。</p><p><font color="red">反序列化</font>：把字节序列恢复为对象的过程称为对象的反序列化。</p><p>从概念上看，<strong>序列化操作只是针对于对象层面的</strong>，包含对象的成员变量和成员方法。那么被static修饰的成员变量呢？结论是被static修饰的属性不会被序列化。</p><p>但这并不意味着static修饰的变量会缺失。这个变量不管被什么修饰词修饰，始终还算对象里边的成员变量。只是可能存在变量值不一致的情况，因为无法序列化代表对象的该变量的值无法硬性写入字节序列（有点饶，描述serialVersionUID进一步阐述）</p><h1 id="2-Serializable接口"><a href="#2-Serializable接口" class="headerlink" title="2. Serializable接口"></a>2. Serializable接口</h1><p>一个对象序列化的接口，<strong>一个类只有实现了Serializable接口，它的对象才能被序列化</strong>。</p><p>日常接触的String类，其底层也实现了Serializable接口，所以JSON字符串才能在前后端自由传输。</p><p>但观察Serializable接口就会发现，接口内部啥也没有，就是说，它是一个空接口。<font color="red">其实，可以将它理解为一个标识接口。实现这个接口，就是给JVM看的，JVM会帮助当前类实现序列化（或反序列化）的具体操作。</font></p><p>Serializable接口就是<font color="red">Java提供用来进行高效率的异地共享实例对象的机制</font>，实现这个接口即可。</p><h1 id="3-serialversionUID变量"><a href="#3-serialversionUID变量" class="headerlink" title="3. serialversionUID变量"></a>3. serialversionUID变量</h1><p>通常的写法是：</p><figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">12356</span>L;</span><br></pre></td></tr></table></figure><p>显示声明这个变量并赋予字面量的作用是啥？保证类的一致性。如果类发生变化，依然能够对旧类的对象（已经序列化）执行反序列化操作。</p><p>很多时候我们未显示声明该变量，程序照常运行。<font color="red">实际上，是JVM在序列化时根据属性自动生成一个serialVersionUID，然后与属性一起序列化。在反序列化时，JVM会再根据属性自动生成一个新版serialVersionUID，然后将新serialVersionUID与旧serialVersionUID比较，如果一致，则反序列化成功，否则报错。</font></p><p>类发生变化（旧类与新类），JVM自动生成的serialVersionUID值就不一致，所以就可能出现问题。</p><h1 id="4-serialversionUID变量也被static修饰"><a href="#4-serialversionUID变量也被static修饰" class="headerlink" title="4. serialversionUID变量也被static修饰"></a>4. serialversionUID变量也被static修饰</h1><p>前面提到，被static修饰的属性不会被序列化，但serialversionUID变量也被static修饰确可以被序列化，这不是打脸吗？</p><p>答案是，你用static修饰的那个变量并没有被序列化，只不过是工具变量拿来传值的。JVM 在序列化对象时会自动生成一个 serialVersionUID, 然后将我们显示指定的 serialVersionUID 属性值赋给自动生成的 serialVersionUID。</p><p>至于其他的static修饰的属性，这些属性是跟着类走的。一种合理的解释是，<font color="red">序列化是针对对象而言的, 而 static 属性优先于对象存在, 随着类的加载而加载, 所以不会被序列化。</font></p><h1 id="5-什么时候需要序列化和反序列化"><a href="#5-什么时候需要序列化和反序列化" class="headerlink" title="5. 什么时候需要序列化和反序列化"></a>5. 什么时候需要序列化和反序列化</h1><p>答案是：<font color="red">对内存中的对象进行数据（指对象的状态信息）传输（通信）与数据存储（持久化）。</font>很多时候我们可能并不是将整个对象存储或者传输，而是其中的字段信息，比如说将数据保存在数据库。这个过程每个字段的变量类型都应该是可序列化的，也即实现了Serializable接口。</p><p>我们经常这么用，但不一定想到原来它们都默默实现了Serializable接口。</p><h1 id="6-参考资料"><a href="#6-参考资料" class="headerlink" title="6. 参考资料"></a>6. 参考资料</h1><p><a href="https://blog.csdn.net/litianxiang_kaola/article/details/100097019" target="_blank" rel="noopener">Java序列化和反序列化为什么要实现Serializable接口</a></p>]]></content>
    
    <summary type="html">
    
      我们经常使用String这个类，但不一定知道原来它实现了Serializable接口。
    
    </summary>
    
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="Serializable接口" scheme="http://yoursite.com/tags/Serializable%E6%8E%A5%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>POJO与JavaBean的区别</title>
    <link href="http://yoursite.com/2020/09/19/POJO%E4%B8%8EJavaBean%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://yoursite.com/2020/09/19/POJO%E4%B8%8EJavaBean%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2020-09-19T15:19:27.000Z</published>
    <updated>2020-09-19T15:21:27.454Z</updated>
    
    <content type="html"><![CDATA[<p>本文转载自 <a href="https://www.jianshu.com/p/224489dfdec8" target="_blank" rel="noopener">简书 (匠丶): java对象 POJO和JavaBean的区别</a></p><p>POJO与JavaBean的区别，其实就是两个概念的区别。</p><p>至于对实际编程有没有太大的影响，倒也没啥。</p><p>只是同行说起来时，大概知道是个啥，谁还不知道这两玩意儿都是类呢！</p><h1 id="POJO"><a href="#POJO" class="headerlink" title="POJO"></a>POJO</h1><p>“Plain Ordinary Java Object”，简单普通的java对象。主要用来指代那些没有遵循特定的java对象模型，约定或者框架的对象。</p><p>POJO的内在含义是指那些:<br>有一些private的参数作为对象的属性，然后针对每一个参数定义get和set方法访问的接口。<br><strong>没有从任何类继承、也没有实现任何接口，更没有被其它框架侵入的java对象。</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BasicInfoVo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String orderId;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Integer uid;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getOrderId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> orderId;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOrderId</span><span class="params">(String orderId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.orderId = orderId;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Integer <span class="title">getUid</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> uid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUid</span><span class="params">(Integer uid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.uid = uid;</span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure><h1 id="JavaBean"><a href="#JavaBean" class="headerlink" title="JavaBean"></a>JavaBean</h1><p>JavaBean 是<strong>一种JAVA语言写成的可重用组件</strong>。JavaBean符合一定规范编写的Java类，不是一种技术，而是一种规范。大家针对这种规范，总结了很多开发技巧、工具函数。符合这种规范的类，可以被其它的程序员或者框架使用。它的方法命名，构造及行为必须符合特定的约定：</p><ul><li><p><strong>所有属性为private</strong>。</p></li><li><p>这个类必须有一个公共的缺省构造函数。即是<strong>提供无参数的构造器</strong>。</p></li><li><p>这个类的<strong>属性使用getter和setter来访问</strong>，其他方法遵从标准命名规范。</p></li><li><p>这个类应是可序列化的。<strong>实现serializable接口</strong>。</p></li></ul><p>因为这些要求主要是靠约定而不是靠实现接口，所以<strong>许多开发者把JavaBean看作遵从特定命名约定的POJO</strong>。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserInfo</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span>&#123;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//实现serializable接口。  </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">private</span> String name;  </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> age;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//无参构造器  </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">UserInfo</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">      </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> name;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">this</span>.name = name;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> age;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">this</span>.age = age;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">//javabean当中可以有其它的方法  </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">userInfoPrint</span><span class="params">()</span></span>&#123;  </span><br><span class="line">    System.out.println(<span class="string">""</span>);  </span><br><span class="line">&#125;  &#125;</span><br></pre></td></tr></table></figure><h1 id="两者有什么区别"><a href="#两者有什么区别" class="headerlink" title="两者有什么区别"></a>两者有什么区别</h1><p>POJO其实是比javabean更纯净的简单类或接口。POJO严格地遵守简单对象的概念，而一些JavaBean中往往会封装一些简单逻辑。</p><p>POJO主要用于数据的临时传递，它只能装载数据， 作为数据存储的载体，而不具有业务逻辑处理的能力。</p><p>Javabean虽然数据的获取与POJO一样，但是javabean当中可以有其它的方法。</p>]]></content>
    
    <summary type="html">
    
      曾经理解得不清楚，放在这里纪念与怀念
    
    </summary>
    
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="概念" scheme="http://yoursite.com/tags/%E6%A6%82%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>面向对象设计原则</title>
    <link href="http://yoursite.com/2020/09/19/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"/>
    <id>http://yoursite.com/2020/09/19/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/</id>
    <published>2020-09-19T14:45:37.000Z</published>
    <updated>2020-09-19T14:49:13.158Z</updated>
    
    <content type="html"><![CDATA[<p>软件开发设计模式，不见得都会用到，但不得不知道。</p><p>设计模式是经验总结的成果，说里边蕴藏着多妙的思想也好，说已经成为开发的规范也罢，无非就是提升<strong>系统稳定性与可维护性</strong>的手段。</p><p>它们是设计方法，但也不是全能的。</p><p>现在编程世界里出现众多框架，约定规范，日趋完善的IDE，归根结底就是为了效益。<strong>低成本，高效率，是最终目的。</strong></p><p>java中有23种设计模式，都是围绕六大设计原则的具体运用。</p><p>六大设计原则看起来容易理解，实际实现起来也偶有冲突，取舍适当即可。</p><p>那就开始知道，皮毛也是毛，蚂蚁肉也是肉！</p><h1 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h1><p><font color="red"><strong>软件实体应当对扩展开放，对修改关闭</strong>。软件开发的终极目标。</font></p><p>当应用的需求改变时，在不修改软件实体的源代码或者二进制代码的前提下，可以扩展模块的功能，使其满足新的需求。</p><p>软件实体包括：项目划分的模块，类/接口，方法。</p><p>实现方法： </p><p><strong>“抽象约束、封装变化”</strong>。通过接口或者抽象类为软件实体定义一个相对稳定的抽象层，而将相同的可变因素封装在相同的具体实现类中。</p><p>好处：  </p><ul><li>软件测试可以只测扩展的代码，不必重复测试基础代码</li><li>提升可复用性</li><li>提高软件的可维护性</li></ul><h1 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h1><p><font color="red"><strong>更愿意称之为继承原则</strong>。继承必须确保超类所拥有的性质在子类中仍然成立。</font></p><p>通俗来讲，<strong>子类可以扩展父类的功能，但不能改变父类原有的功能</strong>。子类继承父类时，除添加新的方法完成新增功能外，尽量不要重写父类的方法。</p><p>实现方法：</p><p>使用继承时，遵循里氏替换原则。类T2继承类T1时，除添加新的方法完成新增功能P2外，尽量不要重写父类T1的方法，也尽量不要重载父类T1的方法。</p><p>例外：当父类存在缺省实现的方法时；需要实现多态时要求重写/重载；部分子类继承父类（类方法体为空）时，必须要求重写。  </p><p>好处：</p><p>继承原则实际上保证父类的可复用性，是继承复用的基础。</p><h1 id="依赖倒置原则"><a href="#依赖倒置原则" class="headerlink" title="依赖倒置原则"></a>依赖倒置原则</h1><p><font color="red"><strong>核心要义是面向接口编程，不要面向实现编程</strong>。高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象。</font></p><p>在软件设计中，细节具有多变性，而抽象层则相对稳定，因此<strong>以抽象为基础搭建起来的架构要比以细节为基础搭建起来的架构要稳定得多</strong>。这里的抽象指接口或抽象类，细节指具体实现类。</p><p>使用接口或者抽象类的目的是制定好规范和契约。</p><p>实现方法：</p><ul><li>每个类尽量提供接口或抽象类，或者两者都具备</li><li>变量的声明类型尽量是接口或者是抽象类</li><li>任何类都不应该从具体类派生</li><li>使用继承时尽量遵循里氏替换原则</li></ul><p>好处：</p><ul><li>降低类之间的耦合性</li><li>提高系统稳定性</li><li>减少并行开发引起的风险</li><li>提高代码的可读性与可维护性</li></ul><h1 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h1><p><font color="red"><strong>就是说每个类的功能相对独立</strong>。单一职责原则规定一个类应该有且仅有一个引起它变化的原因，否则类应该被拆分。</font></p><p>若一个类T有职责A、B，当需要变更职责A时，更改类T可能会影响职责B的正常应用</p><p>实现方法：  </p><p>看似简单实则不易，只是需要优秀设计。需要设计人员<strong>发现类的不同职责并将其分离</strong>，再封装到不同的类或模块中。考验分析设计能力和重构经验。</p><p>好处：</p><ul><li>降低类的复杂度</li><li>提高类的可读性</li><li>提高系统的可维护性</li><li>变更引起的风险降低</li></ul><h1 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h1><p><font color="red"><strong>一个类对另一个类的依赖应该建立在最小的接口上</strong>。客户端不应该被迫依赖于它不使用的方法。程序员需要尽量将臃肿庞大的接口拆分成更小的和更具体的接口，让接口中只包含客户感兴趣的方法。</font></p><p>要为各个类建立它们需要的专用接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用。</p><p>接口隔离原则和单一职责都是为了<strong>提高类的内聚性、降低它们之间的耦合性</strong>，体现了封装的思想。</p><p>但单一职责原则注重的是职责，而接口隔离原则注重的是对接口依赖的隔离。</p><p>且单一职责原则主要是约束类，它针对的是程序中的实现和细节；接口隔离原则主要约束接口，主要针对抽象和程序整体框架的构建。</p><p>实现方法：</p><ul><li>接口尽量小，但是要有限度</li><li>为依赖接口的类定制服务</li><li>接口拆分的标准需要深入了解业务逻辑</li><li>使接口用最少的方法去完成最多的事情</li></ul><p>好处：</p><ul><li>粒度小的接口，可以预防外来变更的扩散，提高系统的灵活性和可维护性</li><li>高了系统的内聚性，降低了系统的耦合性</li><li>能减少项目工程中的代码冗余（过大的大接口里面通常放置许多不用的方法，这些方法可能被冗余实现）</li></ul><p>注意接口的粒度。如果定义过小，则会造成接口数量过多，使设计复杂化；如果定义太大，灵活性降低，无法提供定制服务，给整体项目带来无法预料的风险。</p><h1 id="迪米特原则"><a href="#迪米特原则" class="headerlink" title="迪米特原则"></a>迪米特原则</h1><p><font color="red"><strong>只与你的直接朋友交谈，不跟“陌生人”说话。最少知识原则，只知道朋友</strong>。如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用。</font></p><p>这里的朋友是指：<strong>当前对象本身、当前对象的成员对象、当前对象所创建的对象、当前对象的方法参数</strong>等，这些对象同当前对象存在关联、聚合或组合关系，可以直接访问这些对象的方法。</p><p>目的就是降低类之间的耦合度，提高模块的相对独立性。</p><p>实现方法：<br>从依赖者的角度来说，只依赖应该依赖的对象。从被依赖者的角度说，只暴露应该暴露的方法。</p><ul><li>在类的结构设计上，尽量降低类成员的访问权限</li><li>在类的设计上，优先考虑将一个类设置成不变类</li><li>在对其他类的引用上，将引用其他对象的次数降到最低。</li><li>不暴露类的属性成员，而应该提供相应的访问器（set 和 get 方法）</li><li>谨慎使用序列化（Serializable）功能</li></ul><p>好处：</p><ul><li>降低了类之间的耦合度，提高了模块的相对独立性</li><li>由于亲合度降低，从而提高了类的可复用率和系统的扩展性</li></ul><p>过度使用迪米特法则会使系统产生大量的中介类，从而增加系统的复杂性，使模块之间的通信效率降低。</p><h1 id="合成复用原则"><a href="#合成复用原则" class="headerlink" title="合成复用原则"></a>合成复用原则</h1><p><font color="red"><strong>组合/聚合复用原则。在软件复用时，要尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现</strong>。合成复用原则同里氏替换原则相辅相成的，两者都是开闭原则的具体实现规范。</font></p><p>通常类的复用分为继承复用和合成复用两种。</p><p>继承复用也叫“白箱”复用，简单易实现。但</p><ul><li>子类与父类的耦合度高</li><li>继承会将父类的实现细节暴露给子类（父类透明）</li><li>从父类继承而来的实现是静态的，在编译时已经定义，所以在运行时不可能发生变化</li></ul><p>组合或聚合复用，将已有对象纳入新对象中，使之成为新对象的一部分，新对象可以调用已有对象。这样</p><ul><li>它维持了类的封装性。因为成分对象的内部细节是新对象看不见的，所以这种复用又称为“黑箱”复用</li><li>新旧类之间的耦合度低。这种复用所需的依赖较少，新对象存取成分对象的唯一方法是通过成分对象的接口</li><li>复用的灵活性高。这种复用可以在运行时动态进行，新对象可以动态地引用与成分对象类型相同的对象</li></ul><p>实现方法：<br>合成复用原则是通过将已有的对象纳入新对象中，作为新对象的成员对象来实现的，新对象可以调用已有对象的功能，从而达到复用。就是<strong>需要某类里边的方法，不用去继承该类，直接以其对象作为本类的成员，再进行调用</strong>。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://c.biancheng.net/design_pattern/" target="_blank" rel="noopener">C语言中文网：Java设计模式</a></p>]]></content>
    
    <summary type="html">
    
      面向对象设计原则真的是近在眼前又远在天边 ！
    
    </summary>
    
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="概念" scheme="http://yoursite.com/tags/%E6%A6%82%E5%BF%B5/"/>
    
      <category term="设计原则" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"/>
    
  </entry>
  
  <entry>
    <title>docker通过nginx镜像部署静态文件</title>
    <link href="http://yoursite.com/2020/09/18/docker%E9%80%9A%E8%BF%87nginx%E9%95%9C%E5%83%8F%E9%83%A8%E7%BD%B2%E9%9D%99%E6%80%81%E6%96%87%E4%BB%B6/"/>
    <id>http://yoursite.com/2020/09/18/docker%E9%80%9A%E8%BF%87nginx%E9%95%9C%E5%83%8F%E9%83%A8%E7%BD%B2%E9%9D%99%E6%80%81%E6%96%87%E4%BB%B6/</id>
    <published>2020-09-18T06:22:58.000Z</published>
    <updated>2020-09-18T06:29:20.531Z</updated>
    
    <content type="html"><![CDATA[<p>docker通过nginx镜像部署项目的实质，就是<strong>将（项目）静态文件和及其依赖（nginx）制作成镜像(image)，然后通过镜像生成容器</strong>的过程。这样，通过运行容器就能运行服务，而且image可以方便分享。</p><p>准备工作包括：需要部署的静态文件，自定义的nginx配置文件，<strong>Dockerfile文件</strong>（制作镜像）。</p><h2 id="1-获得打包后的静态文件"><a href="#1-获得打包后的静态文件" class="headerlink" title="1. 获得打包后的静态文件"></a>1. 获得打包后的静态文件</h2><p>vue项目与react项目的打包方式不一样，基本上执行<code>yarn build</code>类似的指令就可以构建打包，获得<code>dist/</code>目录（内部保存的就是静态文件）。一般而言，开发环境中<code>node_module</code>依赖包特别多，打包过程只有用到的依赖进入了静态文件。所以开发环境中项目可能几个GB，但打包完成的静态文件只占几十MB。</p><h2 id="2-准备default-conf文件"><a href="#2-准备default-conf文件" class="headerlink" title="2. 准备default.conf文件"></a>2. 准备default.conf文件</h2><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">===</span> <span class="string">default.conf文件（替换nginx镜像中默认的配置文件）</span> <span class="string">===</span></span><br><span class="line"></span><br><span class="line"><span class="string">server</span> <span class="string">&#123;</span></span><br><span class="line">    <span class="string">listen</span>       <span class="number">3000</span><span class="string">;</span> <span class="string">//项目中的端口号(真实使用#注释)</span></span><br><span class="line">    <span class="string">server_name</span>  <span class="string">localhost;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#charset koi8-r;</span></span><br><span class="line">    <span class="comment">#access_log  /var/log/nginx/log/host.access.log  main;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">location</span> <span class="string">/</span> <span class="string">&#123;</span></span><br><span class="line">        <span class="string">root</span>   <span class="string">/usr/share/nginx/html;</span>   <span class="string">//配置url映射的真实位置</span></span><br><span class="line">        <span class="string">index</span>  <span class="string">index.html</span> <span class="string">index.htm;</span></span><br><span class="line">    <span class="string">&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#error_page  404              /404.html;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># redirect server error pages to the static page /50x.html</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="string">error_page</span>   <span class="number">500</span> <span class="number">502</span> <span class="number">503</span> <span class="number">504</span>  <span class="string">/50x.html;</span></span><br><span class="line">    <span class="string">location</span> <span class="string">=</span> <span class="string">/50x.html</span> <span class="string">&#123;</span></span><br><span class="line">        <span class="string">root</span>   <span class="string">html;</span></span><br><span class="line">    <span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="3-编写Dockerfile文件"><a href="#3-编写Dockerfile文件" class="headerlink" title="3. 编写Dockerfile文件"></a>3. 编写Dockerfile文件</h2><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">===</span> <span class="string">Dockerfile文件</span> <span class="string">===</span></span><br><span class="line"></span><br><span class="line"><span class="string">FROM</span> <span class="attr">nginx:1.14.0</span> <span class="string">//使用Nginx作为基础镜像（从镜像仓库拉取）</span></span><br><span class="line"></span><br><span class="line"><span class="string">MAINTAINER</span> <span class="string">ldj</span> <span class="string">//作者</span></span><br><span class="line"></span><br><span class="line"><span class="string">RUN</span> <span class="string">rm</span> <span class="string">/etc/nginx/conf.d/default.conf</span> <span class="string">//删除nginx</span> <span class="string">默认配置(后边路径说明nginx镜像以linux系统作为基础镜像)</span></span><br><span class="line"></span><br><span class="line"><span class="string">ADD</span> <span class="string">default.conf</span> <span class="string">/etc/nginx/conf.d/</span> <span class="string">//添加我们自己的配置</span> <span class="string">default.conf</span> <span class="string">在下面</span></span><br><span class="line"></span><br><span class="line"><span class="string">COPY</span> <span class="string">dist/</span>  <span class="string">/usr/share/nginx/html/</span>  <span class="string">//把刚才生成dist文件夹下的文件copy到nginx下面去</span></span><br></pre></td></tr></table></figure><h2 id="4-创建镜像"><a href="#4-创建镜像" class="headerlink" title="4. 创建镜像"></a>4. 创建镜像</h2><figure class="highlight vala"><table><tr><td class="code"><pre><span class="line"><span class="meta"># 当前文件结构</span></span><br><span class="line"></span><br><span class="line">├── <span class="keyword">default</span>.conf</span><br><span class="line">├── dist</span><br><span class="line">└── Dockerfile</span><br><span class="line"></span><br><span class="line"><span class="meta"># docker打包</span></span><br><span class="line"><span class="meta"># -t指定镜像名称:版本号（tag）</span></span><br><span class="line">docker image build -t biggfish:<span class="number">1.0</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># 生成容器</span></span><br><span class="line"><span class="meta"># 末尾千万不要加 /bin/bash 否则端口不能正常映射</span></span><br><span class="line">docker container run -p <span class="number">3000</span>:<span class="number">3000</span> -itd --name biggfishContainer biggfish:<span class="number">1.0</span></span><br></pre></td></tr></table></figure><h2 id="5-访问测试"><a href="#5-访问测试" class="headerlink" title="5. 访问测试"></a>5. 访问测试</h2><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">通过 本机ip:<span class="number">3000</span> 访问</span><br><span class="line"></span><br><span class="line">如果能看到项目首页：成功</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      自制镜像体验卡
    
    </summary>
    
    
      <category term="docker" scheme="http://yoursite.com/categories/docker/"/>
    
    
      <category term="docker" scheme="http://yoursite.com/tags/docker/"/>
    
      <category term="教程" scheme="http://yoursite.com/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="nginx" scheme="http://yoursite.com/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>docker常用指令</title>
    <link href="http://yoursite.com/2020/09/18/docker%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/"/>
    <id>http://yoursite.com/2020/09/18/docker%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/</id>
    <published>2020-09-18T06:08:59.000Z</published>
    <updated>2020-10-12T08:32:40.069Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight vala"><table><tr><td class="code"><pre><span class="line"><span class="meta"># 进入容器</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//（run方式）运行容器时在使用 -d 参数时，容器启动后会进入后台</span></span><br><span class="line"><span class="comment">// -it参数：命令提示符效果（i：交互式 t：伪终端）</span></span><br><span class="line"><span class="comment">// /bin/bash 参数表明进入容器后执行的cmd命令（使用shell指令）</span></span><br><span class="line"></span><br><span class="line">docker exec -it 容器id /bin/bash</span><br><span class="line"></span><br><span class="line"><span class="comment">//退出当前容器（exec进入，exit退出时不停止容器；attach进入，停止）</span></span><br><span class="line"></span><br><span class="line">exit</span><br><span class="line"></span><br><span class="line"><span class="meta"># 拉取镜像（从docker hub镜像仓库）</span></span><br><span class="line">docker pull nginx(镜像名称)</span><br><span class="line"></span><br><span class="line"><span class="meta"># 查看镜像 </span></span><br><span class="line">docker images</span><br><span class="line"></span><br><span class="line"><span class="meta"># 创建镜像（提前写好Dockerfile） </span></span><br><span class="line"><span class="comment">// -t 指定构建的镜像名称（target）</span></span><br><span class="line">docker image build -t diyimage:<span class="number">0.0</span><span class="number">.1</span> .</span><br><span class="line"></span><br><span class="line"><span class="meta"># 删除镜像 </span></span><br><span class="line"><span class="comment">// -f参数：force</span></span><br><span class="line">docker image rm 镜像id</span><br><span class="line">docker rmi [-f] 镜像id</span><br><span class="line"></span><br><span class="line"><span class="meta"># 通过镜像生成容器 </span></span><br><span class="line">docker container run -p <span class="number">8000</span>:<span class="number">3000</span> -itd --name 容器名称 image01:<span class="number">0.0</span><span class="number">.1</span> /bin/bash</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">注：</span></span><br><span class="line"><span class="comment">每次run都会新增容器</span></span><br><span class="line"><span class="comment">-p参数：容器的 3000 端口映射到本机的 8000 端口。</span></span><br><span class="line"><span class="comment">-it参数：容器的 Shell 映射到当前的 Shell，然后你在本机窗口输入的命令，就会传入容器。</span></span><br><span class="line"><span class="comment">-d参数：容器生成后，后台运行</span></span><br><span class="line"><span class="comment">--name参数：指定容器的名称（不指定系统随机命名）</span></span><br><span class="line"><span class="comment">image01:0.0.1：image 文件的名字（如果有标签，还需要提供标签，默认是 latest 标签）</span></span><br><span class="line"><span class="comment">/bin/bash：容器启动以后，内部第一个执行的命令。这里是启动 Bash，保证用户可以使用 Shell。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">又注：如果镜像是基于nginx的，则不要写/bin/bash，否则映射出去的端口失效(无法访问)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># 停止/启动容器 </span></span><br><span class="line">docker container kill/stop/start [containID]</span><br><span class="line"></span><br><span class="line"><span class="meta"># 删除容器 </span></span><br><span class="line">docker container rm 容器id</span><br><span class="line"></span><br><span class="line"><span class="meta"># 查看容器 </span></span><br><span class="line">docker container ls</span><br><span class="line">docker container ls -all</span><br><span class="line"></span><br><span class="line">docker ps</span><br><span class="line">docker ps -a</span><br><span class="line"></span><br><span class="line"><span class="meta"># 保存镜像（eg：viewer-镜像名） </span></span><br><span class="line"></span><br><span class="line">docker save viewers-images  -o  /home/ldj/viewers-image.tar</span><br><span class="line"></span><br><span class="line"><span class="meta"># 载入本地镜像 </span></span><br><span class="line"></span><br><span class="line">docker load -i viewers-image.tar</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      docker常用指令备忘录
    
    </summary>
    
    
      <category term="docker" scheme="http://yoursite.com/categories/docker/"/>
    
    
      <category term="docker" scheme="http://yoursite.com/tags/docker/"/>
    
      <category term="命令" scheme="http://yoursite.com/tags/%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>常见乱码问题及分析</title>
    <link href="http://yoursite.com/2020/07/03/%E5%B8%B8%E8%A7%81%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98%E5%8F%8A%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2020/07/03/%E5%B8%B8%E8%A7%81%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98%E5%8F%8A%E5%88%86%E6%9E%90/</id>
    <published>2020-07-03T01:51:25.000Z</published>
    <updated>2020-07-03T01:59:53.021Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>有一个现成的古老的web项目，技术栈包括<code>JSP</code> <code>JAVA</code> <code>MYSQL</code>，<code>MyEclipse 10.5</code>作为开发工具，开发环境<code>JDK1.7</code> <code>Tomcat7</code> <code>Mysql5.5</code>。</p><p>现在项目能够部署成功，正常访问。</p><p>但是当提交的表单数据中包含中文时，数据库存储的相关数据显示为???。</p><p>因为这个<code>BUG</code>，诞生这篇小结。</p><p><img src="https://cdn.jsdelivr.net/gh/biggfish3147/pics/blog/pk0001.png" alt="朋克风"></p><h1 id="常见乱码问题分析和总结"><a href="#常见乱码问题分析和总结" class="headerlink" title="常见乱码问题分析和总结"></a>常见乱码问题分析和总结</h1><p>本节内容选自<a href="https://www.ibm.com/developerworks/cn/java/analysis-and-summary-of-common-random-code-problems/index.html" target="_blank" rel="noopener">IBM Developer : 常见乱码问题分析和总结 </a></p><h2 id="编码与解码"><a href="#编码与解码" class="headerlink" title="编码与解码"></a>编码与解码</h2><p>计算机不能直接存储字母，数字，图片，符号等，计算机能处理和工作的唯一单位是”比特位（bit）”，一个比特位通常只有 0 和 1，是（yes）和否（no），真（true）或者假（false）等等我们喜欢的称呼。利用比特位序列来代表字母，数字，图片，符号等，我们就需要一个存储规则，不同的比特序列代表不同的字符，这就是所谓的”编码”。反之，将存储在计算机中的比特位序列（或者叫二进制序列）解析显示出来成对应的字母，数字，图片和符号，称为”解码”，如同密码学中的加密和解密，下面将详细解释编码解码过程中涉及到的一些术语：</p><p><strong>字符集合（Character set）</strong>：是各种文字和符号的总称，包括各国家文字、标点符号、图形符号、数字等，简单理解就是一个字库，与计算机以及编码无关。</p><p><strong>字符编码集（Coded character set）</strong>：是一组字符对应的编码（即数字），为字符集合中的每一个字符给予一个数字，如 Unicode 为每一个字符分配一个唯一的码点与之一一对应。</p><p><strong>字符编码（Character Encoding）</strong>：简单理解就是一个映射关系，将字符集对应的码点映射为一个个二进制序列，从而使得计算机可以存储和处理。常见的编码方式有 ASCII 编码、ISO-8859-1(不支持中文)、GBK、GB2312（中国编码，支持中文）、UTF-8 等等,详情见表 1。</p><p><strong>字符集（Charset）</strong>：包括编码字符集合和字符编码，如 ASCII 字符集、ISO-8859-X、GB2312 字符集（简中）、BIG5 字符集（繁中）、GB18030 字符集、Shift-JIS 等，即下文中提到的字符集。</p><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">笔者注：</span><br><span class="line">这里提到的字符集合与字符集是不同的概念，后者包含前者。</span><br><span class="line">一般乱码现象都是因为中文数据导致的，汉字占用双字节，所以支持中文的编码方式（GBK、UTF<span class="number">-8</span>等）也就是可以支持对双字节汉字进行编码。</span><br></pre></td></tr></table></figure><p><strong>字符解码（Character Decoding）</strong>: 根据一定规则，将二进制序列映射成对应的正确字符串，即二进制序列–&gt;字符串，个人将其理解为”翻译”。</p><p><strong>Code Point</strong>：称作码点或码位，是组成编码空间（或代码页）的数值。例如，ASCII 码包含 128 个码点，范围是 0 到 7F（16 进制）；ISO-8859-1 包含 256 个码点，范围是 0 到 FF；而 Unicode 包含 1,114,112 个码点，范围是 0 到 10FFFF。Unicode 码空间划分为 17 个 Unicode 字符平面（基本多文种平面，16 个辅助平面），每个平面有 65,536（= 216）个码点。因此 Unicode 码空间总计是 17 x 65,536 = 1,114,112。</p><p><strong>Code Page</strong>：代码页或者内码表，是 IBM 早期称呼计算机的 BIOS 所支持的字符集编码（也称作 OEM 代码页）。Windows 系统在没有使用 UTF-16 之前，为了解决由于不同国家和地区采用的字符集不一致，很可能出现无法正常显示所有字符的问题，使用了代码页（Codepage）转换表的技术来过渡性的部分解决这一问题，即定义了一系列支持不同国家和地区所制定的字符集，被称为 Windows 代码页或 ANSI 代码页，然而代码页一般与其所对应的字符集之间并非完全相同，有时候会对字符集有所扩展，可以理解为一张字符-字节序列映射表，通过查表实现编码解码功能。操作系统中不同 Locale 设置默认使用不同的代码页。</p><p><strong>Locale</strong>：是指特定于某个国家或地区的一组设定，包括代码页，以及数字、货币、时间和日期的格式等。在 Windows 内部，有两个 Locale 设置：系统 Locale 和用户 Locale。系统 Locale 决定代码页，用户 Locale 决定数字、货币、时间和日期的格式。</p><h2 id="乱码产生原因"><a href="#乱码产生原因" class="headerlink" title="乱码产生原因"></a>乱码产生原因</h2><p>乱码产生的根源一般情况下可以归结为三方面即：编码引起的乱码、解码引起的乱码以及缺少某种字体库引起的乱码（这种情况需要用户安装对应的字体库），其中大部分乱码问题是由不合适的解码方式造成的，如图 3 所示的鱼骨图。</p><p>图 3. 乱码产生原因</p><p><img src="https://www.ibm.com/developerworks/cn/java/analysis-and-summary-of-common-random-code-problems/image003.jpg" alt="乱码产生原因"></p><h3 id="从普通用户角度分别阐述这几种原因导致的乱码表象和解决办法"><a href="#从普通用户角度分别阐述这几种原因导致的乱码表象和解决办法" class="headerlink" title="从普通用户角度分别阐述这几种原因导致的乱码表象和解决办法"></a>从普通用户角度分别阐述这几种原因导致的乱码表象和解决办法</h3><p>图 5. 编码方式引起的乱码剖析</p><p><img src="https://www.ibm.com/developerworks/cn/java/analysis-and-summary-of-common-random-code-problems/image005.jpg" alt="图 5. 编码方式引起的乱码剖析"></p><p>图 6. 不正确的解码方式引起的乱码</p><p><img src="https://www.ibm.com/developerworks/cn/java/analysis-and-summary-of-common-random-code-problems/image006.png" alt="图 6. 不正确的解码方式引起的乱码"></p><figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">笔者注：</span><br><span class="line">乱码有很多形式。</span><br><span class="line"><span class="string">"??"</span>通常是由于编码引起的乱码，出现?说明原始字符的信息已经丢失，这种情况下形成的乱码是不可逆的，也就是说无论用什么解码方式都不能正确显示字符。</span><br><span class="line"><span class="string">"ÄãºÃ£¬ÖÐ¹ú"</span>一般由解码方式不对引起的，乱码可逆，即可以通过乱码恢复获取原始的字符信息。</span><br></pre></td></tr></table></figure><h3 id="从编程角度分析出现乱码的场景和解决办法"><a href="#从编程角度分析出现乱码的场景和解决办法" class="headerlink" title="从编程角度分析出现乱码的场景和解决办法"></a>从编程角度分析出现乱码的场景和解决办法</h3><p>从编程角度来看，出现乱码的场景主要是有文本处理的时候，比如文件的新建和读取、复制和粘贴，导入和导出，打开和保存，数据存储和检索，显示，打印，分词处理，字符转换，规范化，搜索，整理和发送数据等，文本数据的示例包括平面文件，流文件，数据区域，目录名称，资源名称，用户标识等。图 9 是出现乱码的一个常见场景分类。</p><p>图 9. 出现乱码的场景</p><p><img src="https://www.ibm.com/developerworks/cn/java/analysis-and-summary-of-common-random-code-problems/image009.jpg" alt="出现乱码的场景"></p><p><strong>Web 程序中出现的乱码情况</strong></p><p>在 web 应用程序中，存在用户输入以及输出显示的地方都有可能存在编码解码，图 12 简要概括了 HTTP web 请求响应环节。</p><p>图 12. Web 请求响应环节中的编码解码</p><p><img src="https://www.ibm.com/developerworks/cn/java/analysis-and-summary-of-common-random-code-problems/image012.jpg" alt="请求响应环节中的编码解码"></p><p><strong>数据库操作过程中的乱码</strong></p><p>在实际应用中，和数据库操作相关的乱码可能出现在数据的导入和导出操作中，在整个过程中涉及到的字符集有服务器端数据库字符集、客户端操作系统字符集、客户端环境变量 nls_lang(lang_territory.charset)，这三个参数的工作流程如图 15 所示。如果这三个参数设置一样，整个数据库操作中就不会出现乱码问题，但是实际应用中客户端的情况复杂多样，很难保持三者一致，涉及到双字节字符就需要服务器端进行转码操作，而转码的桥梁就是 Unicode 字符集，这就要求数据库本身支持 UTF-8 编码方式。为了编码数据库操作过程中的乱码问题，在创建数据库的时候使用 UTF-8 编码方式，如果仅在某些列中使用多语言数据，则可以使用 SQL NCHAR 数据类型（NCHAR，NVARCHAR2 和 NCLOB）以 UTF-16 或 UTF-8 编码形式存储 Unicode 数据，避免存储空间的浪费。</p><p>图 15. Oracle 数据库字符集</p><p><img src="https://www.ibm.com/developerworks/cn/java/analysis-and-summary-of-common-random-code-problems/image015.jpg" alt="Oracle 数据库字符集"></p><h1 id="修改Windows的默认编码"><a href="#修改Windows的默认编码" class="headerlink" title="修改Windows的默认编码"></a>修改Windows的默认编码</h1><p>在Windows设置-时间与语言-语言-管理语言设置-更改系统区域设置中进行修改。</p><p>联想到一个现象：通过执行startup.bat文件开启tomcat服务器时，打印的启动日志出现乱码。</p><p>通过查询cmd的编码格式，并修改为utf-8编码格式，理论上能够解决上述乱码问题。实际上，执行chcp 65001，只是将当前cmd窗口的编码设置为utf-8。执行startup.bat时，会另外启动一个cmd进程，所以打印服务器启动日志的那个cmd窗口还是会有乱码。（除非从操作系统层面更改编码格式）</p><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//查看当前cmd的编码格式</span></span><br><span class="line"><span class="comment">//character code page</span></span><br><span class="line">chcp</span><br><span class="line"></span><br><span class="line"><span class="comment">//换成utf-8代码页</span></span><br><span class="line">chcp <span class="number">65001</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//换成默认的gbk</span></span><br><span class="line">chcp <span class="number">936</span></span><br></pre></td></tr></table></figure><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>现在回过头来想背景中的问题。??的出现有可能是字符的编码方式不对，导致通过任何解码方式都读不出正确的字符。那么在哪个环节出现了这个问题呢？通过测试，表单数据提交到服务端，服务端获取数据并打印，显示正常。说明在浏览器到web服务端的编码解码方式是OK的。那么再来，就是java程序代码中将正常的字符数据存入数据库时发生了问题，导致数据库中数据显示为??。于是考虑中文存入数据库的编码方式出了问题。事实也应该就是这样的。</p><p>【问题解决】java连接数据库的代码中，DBURL设置为<code>jdbc:mysql://localhost:3306/XXX?useUnicode=true&amp;characterEncoding=UTF-8</code>。重点就是后边的characterEncoding参数。</p><p>字符数据在二进制与可识读形式之间来回切换跳转，编码解码的步骤都是循环重复的。博大精深的中国汉字，到底在代码的世界里也很独特。</p><p>尽管问题解决，原因大概分析了，但真实的情形又是怎样的呢？谁又真正的可知？如果能够化身数据流，以数据本身的角度来看浏览器到数据库的往返之路，这该是很奇妙的想象与体验吧。</p><p><img src="https://cdn.jsdelivr.net/gh/biggfish3147/pics/blog/hacker.png" alt="hacker"></p>]]></content>
    
    <summary type="html">
    
      经常看到的乱码，到底如何产生的
    
    </summary>
    
    
      <category term="常识" scheme="http://yoursite.com/categories/%E5%B8%B8%E8%AF%86/"/>
    
    
      <category term="乱码" scheme="http://yoursite.com/tags/%E4%B9%B1%E7%A0%81/"/>
    
      <category term="编码" scheme="http://yoursite.com/tags/%E7%BC%96%E7%A0%81/"/>
    
      <category term="解码" scheme="http://yoursite.com/tags/%E8%A7%A3%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>kindle电子书邮箱推送</title>
    <link href="http://yoursite.com/2020/06/08/kindle%E7%94%B5%E5%AD%90%E4%B9%A6/"/>
    <id>http://yoursite.com/2020/06/08/kindle%E7%94%B5%E5%AD%90%E4%B9%A6/</id>
    <published>2020-06-08T14:06:52.000Z</published>
    <updated>2020-06-08T14:17:18.666Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Kindle入手后已经吃过太多灰，<del>白嫖</del>收集的电子书资源怎么导入到Kindle设备都快忘记了，避免后续再次各处看教程，简单记录。</p><p><img src="https://cdn.jsdelivr.net/gh/biggfish3147/pics/blog/ilR0005.jpg" alt="人丑就要多读书"></p><h1 id="电子书资源"><a href="#电子书资源" class="headerlink" title="电子书资源"></a>电子书资源</h1><ul><li><del>有钱</del> 最好直接在Amazon官方商城购买（一步到位）</li><li><a href="https://www.jiumodiary.com/" target="_blank" rel="noopener">鸠摩</a></li><li><a href="https://sobooks.cc/" target="_blank" rel="noopener">SoBooks</a></li><li><a href="http://cn.epubee.com/books/" target="_blank" rel="noopener">ePUBee</a> （收费）</li></ul><h1 id="将电子书导入到Kindle"><a href="#将电子书导入到Kindle" class="headerlink" title="将电子书导入到Kindle"></a>将电子书导入到Kindle</h1><p>Kindle支持的电子书格式Kindle格式包括但不限于<code>.mobi</code>  <code>.azw</code> <code>.pdf</code>，不支持<code>.epub</code>格式，但可以通过电子书格式<a href="http://cn.epubee.com/" target="_blank" rel="noopener">转换工具</a>进行转换。</p><h2 id="USB数据线导入"><a href="#USB数据线导入" class="headerlink" title="USB数据线导入"></a>USB数据线导入</h2><p><strong>步骤</strong></p><ul><li>数据线（Micro USB口）连接Kindle与电脑</li><li>将电子书资源拷贝到Kindle磁盘的Documents文件夹  </li></ul><p><strong>注意</strong></p><ul><li>只能在Kindle设备上阅读，不能同步到同一账号下</li></ul><h2 id="邮箱推送"><a href="#邮箱推送" class="headerlink" title="邮箱推送"></a>邮箱推送</h2><p><strong>步骤</strong></p><ul><li>在Amazon账户下，管理我的内容与设备，进行个人文档设置（电子邮箱白名单）</li><li>将电子书资源（支持格式）作为邮件附件发送到***@kindle.cn邮件地址</li></ul><p><strong>注意</strong></p><ul><li>电子书资源能够同步到同一账号下</li></ul><h2 id="其他导入方式"><a href="#其他导入方式" class="headerlink" title="其他导入方式"></a>其他导入方式</h2><ul><li>公众号【亚马逊Kindle服务号】将文章推送到 Kindle</li><li>通过Calibre 传书到Kindle</li><li>通过手机发送传书到Kindle app（手机本地有电子书资源）</li></ul><h2 id="Kindle使用"><a href="#Kindle使用" class="headerlink" title="Kindle使用"></a>Kindle使用</h2><ul><li>关闭广告（First）</li><li>截屏（可以但没必要）</li><li>笔记/标注（可导出）</li><li>续航真的猛，内存也够大</li><li>Kindle神器Calibre（格式转换/推送）</li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://zhuanlan.zhihu.com/p/83882901" target="_blank" rel="noopener">如何把电子书导入到kindle？</a></li><li><a href="https://www.zhihu.com/question/273617420/answer/996496570" target="_blank" rel="noopener">你们都是从哪里找kindle电子书资源的？</a></li></ul><p><img src="https://cdn.jsdelivr.net/gh/biggfish3147/pics/blog/ilF1005.jpg" alt="What？何不如买个iPad"></p>]]></content>
    
    <summary type="html">
    
      白嫖的电子书怎么通过邮箱推送给Kindle
    
    </summary>
    
    
      <category term="教程" scheme="http://yoursite.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="kindle" scheme="http://yoursite.com/tags/kindle/"/>
    
  </entry>
  
  <entry>
    <title>浅谈图像</title>
    <link href="http://yoursite.com/2020/06/01/%E6%B5%85%E8%B0%88%E5%9B%BE%E5%83%8F/"/>
    <id>http://yoursite.com/2020/06/01/%E6%B5%85%E8%B0%88%E5%9B%BE%E5%83%8F/</id>
    <published>2020-06-01T04:21:54.000Z</published>
    <updated>2020-06-01T04:35:05.884Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>一切要从图像分辨率说起。前不久问过自己一个问题：<strong>小米6只有1920x1080的分辨率为什么能拍出4032x3016px的照片？</strong></p><p>不知当时脑袋想什么，问出这样一个特别蠢的问题。但它居然就这样作为一个导火索，让我不得不去了解一下关于图像的基本知识。</p><p>这里需要说明的是，这个问题本身就是个问题。小米6的分辨率1920x1080是说的屏幕分辨率，而4032x3016px的照片是相机拍出来的图像分辨率，也就是米6后置的1200万像素摄像头拍出来的。一个是屏幕显示分辨率，另一个是拍照图像分辨率，就没得啥关联的。</p><p>然后又因为接触<code>React Native</code>，知道其组件的宽高用的是逻辑像素作为单位。之前买的kindle参数里其中一项是PPI，笔记本外设显示器4K屏……</p><p>于是就简单整理一下图像基础知识及相关概念，权作了解。</p><p><img src="https://cdn.jsdelivr.net/gh/biggfish3147/pics/blog/ilF0001.jpg" alt="图像啊图像"></p><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>位图和矢量图是计算机图形中的两大概念。</p><h2 id="位图"><a href="#位图" class="headerlink" title="位图"></a>位图</h2><p><strong>位图</strong>（bitmap）也叫点阵图、栅格图像、<strong>像素图</strong>。<strong>构成位图的最小单位是像素</strong>，位图就是依靠像素阵列的排列来实现其显示效果的，缩放位图会导致失真（边缘锯齿）。例如放大后的位图出现“马赛克”。</p><p><strong>位图图像善于重现颜色的细微层次</strong>，能够制作出色彩和亮度变化丰富的图像，可逼真地再现这个世界，文件庞大，<strong>不能随意缩放，打印和输出的精度是有限的。</strong></p><p><strong>位图的文件类型</strong>很多，如.bmp、.pcx、.gif、.jpg、.tif等。同样的图形，存盘成以上几种文件时文件的字节数会有一些差别，尤其是jpg格式，它的大小只有同样的bmp格式的1/20到1/35，这是因为它们的点矩阵经过了复杂的压缩算法的缘故。</p><p><strong>位图图像面积越大，图像文件的色彩越丰富，文件的字节数就越多。</strong></p><h2 id="矢量图"><a href="#矢量图" class="headerlink" title="矢量图"></a>矢量图</h2><p><strong>矢量图</strong>（vector）也叫向量图，是一种<strong>缩放不失真</strong>的图像格式。矢量图是通过多个对象的组合生成的，对其中的每一个对象的纪录方式，都是以数学函数来实现的，也就是说，矢量图实际上并不是像位图那样纪录画面上每一点的信息，而是纪录了元素形状及颜色的算法，当你打开矢量图的时候，软件利用图行对应的函数进行运算，将运算结果[图形的形状和颜色]显示给你看。</p><p>矢量图形能<strong>重现清晰的轮廓</strong>，线条非常光滑、且<strong>具有良好的缩放性</strong>。因为图像中保存的是线条和图块的信息，与分辨率和图形大小无关，只与图像的复杂程度有关，所以图像文件所占的存储空间较小（图像不复杂情况下）。</p><p>与位图相比，在显示和打印方面都快的多；<strong>图形不真实生动，颜色不丰富</strong>。无法像照片一样真实地再现这个世界的景色。（矢量图基本都需要专门软件打开）</p><p><strong>矢量图形格式</strong>也很多，常见的如.SVG。</p><p>矢量图形文件的规律：</p><ul><li>可以无限放大图形中的细节，不用担心会造成失真和色块。</li><li>一般的线条的图形和卡通图形，存成矢量图文件就比存成位图文件要小很多。</li><li>存盘后<strong>文件的大小</strong>与图形中<strong>元素的个数</strong>和每个<strong>元素的复杂程度</strong>成正比。而与图形面积和色彩的丰富程度无关。（元素的复杂程度指的是这个元素的结构复杂度，如五角星就比矩形复杂、一个任意曲线就比一个直线段复杂）。</li><li>通过软件，<strong>矢量图可以轻松地转化为位图，而位图转化为矢量图就需要经过复杂而庞大的数据处理</strong>，而且生成的矢量图的质量绝对不能和原来的图形比拟。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/biggfish3147/pics/blog/ilF0002.jpg" alt="图像啊图像"></p><h2 id="一些单位"><a href="#一些单位" class="headerlink" title="一些单位"></a>一些单位</h2><p>绝对单位与相对单位。比如设备尺寸5.15 inch就是绝对的物理长度，像素（pixel）就是相对单位，1英寸显示屏可以只有1个像素，也可以有100个像素。<strong>相同面积不同分辨率的显示屏，其像素点大小就不相同。</strong></p><p><strong>px</strong>：<code>pixel</code>，像素，是<strong>组成数字图像的基本单元</strong>。这种基本单元越多，越能呈现出图像的细节，图像就越清晰。像素的大小是没有固定长度的，不同设备上一个单位像素色块的大小是不一样的。</p><p><strong>ppi</strong> ：<code>pixels per inch</code>,等于屏幕对角线像素点／屏幕对角线物理宽度，是每英寸对角线上所拥有的像素（pixel）数目，通常也叫<strong>像素密度</strong>。手机屏幕的PPI当达到一定数值（300ppi）时，人眼就分辨不出颗粒感了。</p><p><strong>dpi</strong>：<code>dots per inch</code>,是每英寸所能打印的点数，通常也叫<strong>打印精度</strong>。如：打印机输出可达600DPI的分辨率，表示打印机可以在每一平方英寸的面积中可以输出600X600＝360000个输出点。大多数情况下，PPI与DPI的数值是相等的。</p><p><strong>dp</strong>：<code>density-independent pixels</code>,一种基于屏幕密度的抽象单位。在每英寸160点的显示器上，1dp = 1px。<a href="https://developer.android.com/guide/practices/screens_support.html" target="_blank" rel="noopener">dp的提出</a>是为了解决控件对不同屏幕的适配问题。</p><p><strong>sp</strong>：<code>scale-independent pixel</code>，与缩放无关的抽象像素，安卓开发用的字体大小单位。一般情况下可认为sp=dp。</p><p><strong>density</strong> ：密度。density ≈ 设备PPI/160PPI。比如我是320PPI设备，density＝320PPI/160PPI=2;density是一个int类型的值。</p><p><strong>运算案例</strong></p><p>小米6设备参数：显示屏尺寸5.15英寸（1 inch=2.54 cm），分辨率1920x1080px</p><p>计算得：PPI=428 ，density≈3，1dp=2.67px≈3px。</p><h2 id="分辨率"><a href="#分辨率" class="headerlink" title="分辨率"></a>分辨率</h2><p>分辨率，又称解析度。分辨率=画面水平方向的像素值x画面垂直方向的像素值，分为 <strong>屏幕分辨率</strong>和<strong>图像分辨率</strong>。</p><p>显示分辨率（屏幕分辨率）是屏幕图像的精密度，是指<strong>显示器所能显示的像素有多少</strong>。由于屏幕上的点、线和面都是由像素组成的，显示器可显示的像素越多，画面就越精细，同样的屏幕区域内能显示的信息也越多。显示分辨率一定的情况下，显示屏越小图像越清晰，反之，显示屏大小固定时，显示分辨率越高图像越清晰。</p><p>屏幕分辨率1920x1080（16:9显示屏），就是说设备屏幕的水平方向上有1920个像素点，垂直方向上有1080个像素点。<strong>同一台硬件设备上的屏幕分辨率、像素块大小是不会变的（倾向于说显示器分辨率）</strong>。PC电脑上之所以可以调整屏幕分辨率，其实是通过算法转换实现的。</p><p><strong>图像分辨率是指每英寸图像内的像素点数</strong>（这种定义方式更精准）。图像分辨率是有单位的，叫 像素每英寸。分辨率越高，像素的点密度越高（图像尺寸一定时），图像越逼真。</p><p>分辨率和清晰度不能对等，虽然<strong>很多情况下高分辨率的确意味着高清晰度</strong>。比如一张1920x1080尺寸的图片，放在1920x1080分辨率的PC屏幕上显示没问题（大小合适），但放在4K屏上就会发现图片变模糊（失真）了（因为4K屏幕大，图像放大失真）。又比如1920x1080和1280x720的图片作为手机壁纸，其实清晰度看起来差不多的。</p><p><img src="https://cdn.jsdelivr.net/gh/biggfish3147/pics/blog/ilF0012.jpg" alt="图像啊图像"></p><h1 id="图像深度与像素深度"><a href="#图像深度与像素深度" class="headerlink" title="图像深度与像素深度"></a>图像深度与像素深度</h1><p>像素深度和图像深度是两个相互关联但又有所不同的两个概念。</p><h2 id="像素深度"><a href="#像素深度" class="headerlink" title="像素深度"></a>像素深度</h2><p><strong>像素深度</strong>是指<strong>存储每个像素所用的位数</strong>，它也是用来度量图像的分辨率。</p><p><strong>像素深度决定彩色图像的每个像素可能有的颜色数，或者确定灰度图像的每个像素可能有的灰度级数</strong>。例如，一幅彩色图像的每个像素用R，G，B三个分量表示，若每个分量用8位，那么一个像素共用24位表示，就说像素的深度为24，每个像素可以是16 777 216（2的24次方）种颜色中的一种。在这个意义上，往往把像素深度说成是图像深度。表示一个像素的位数越多，它能表达的颜色数目就越多，而它的深度就越深。</p><h2 id="图像深度"><a href="#图像深度" class="headerlink" title="图像深度"></a>图像深度</h2><p><strong>图像深度</strong>是指<strong>像素深度中实际用于存储图像的灰度或色彩所需要的比特位数</strong>。假定图像的像素深度为16bit，但用于表示图像的灰度或色彩的位数只有15位，则图像的图像深度为15。</p><p>在用二进制数表示彩色图像的像素时，除R，G，B分量用固定位数表示外，往往还增加1位或几位作为属性(Attribute)位。例如，RGB 5∶5∶5表示一个像素时，用2个字节共16位表示，其中R，G，B各占5位，剩下一位作为属性位。在这种情况下，像素深度为16位，而图像深度为15位。</p><h2 id="图像通道"><a href="#图像通道" class="headerlink" title="图像通道"></a>图像通道</h2><p>我们都知道颜色的三元素 Red, Green, Blue。 如果是深度为24=3*8，我们刚好就可以用第一个8位存储Red值，第二个存储Green值，第三个存储Blue值, 2的8次方刚好是255,所以我们一般看到的RGB值都是(0-255,0-255,0-255)这样的值。如果用rgb来表示图片的颜色值，我们称这样的图片通道为三。<br>每个像素点都有3个值表示 ，所以就是3通道；也有4通道的图（RGB+alpha），灰度图一般为单通道。</p><h2 id="灰度图像"><a href="#灰度图像" class="headerlink" title="灰度图像"></a>灰度图像</h2><p><strong>灰度</strong>也可以认为是亮度，简单说就是<strong>色彩的深浅程度</strong>。</p><p>灰度图像是二值图像的进化版本，是彩色图像的退化版，也就是灰度图保存的信息没有彩色图像多，但比二值图像多，灰度图只包含一个通道的信息，而彩色图通常包含三个通道的信息。</p><p><strong>灰度数字图像是每个像素只有一个采样颜色的图像</strong>（灰度图没有色彩）。这类图像通常显示为从最暗黑色到最亮的白色的灰度，尽管理论上这个采样可以任何颜色的不同深浅，甚至可以是不同亮度上的不同颜色。灰度图像与黑白图像不同，在计算机图像领域中黑白图像只有黑白两种颜色，灰度图像在黑色与白色之间还有许多级的颜色深度。</p><p><strong>彩色图像可以二值化和灰度化</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/biggfish3147/pics/blog/ilF1021.jpeg" alt="图像啊图像"></p><h1 id="图像格式"><a href="#图像格式" class="headerlink" title="图像格式"></a>图像格式</h1><p>BMP、PNG、GIF、TIF和JPG格式的文件是位图文件，文件的扩展明指明了图像文件的标准。SVG是矢量图文件格式。<font color="red">图片文件格式本质上是一种对图片进行压缩进而减少文件大小的解决方案。</font></p><p>如果将图像原始格式直接存储到文件中将会非常大，比如一个5000x5000 24位图，所占文件大小为5000x5000x3字节=71.5MB, 其大小非常可观。<br>如果用zip或rar之类的通用算法来压缩像素数据，得到的压缩比例通常不会太高，因为这些压缩算法没有针对图像数据结构进行特殊处理。</p><h2 id="jpeg"><a href="#jpeg" class="headerlink" title="jpeg"></a>jpeg</h2><p>全称<code>JointPhotographicExpertsGroup</code>，<br>JEPG格式，也叫做JPG或JPE格式，是最常用的一种文件格式。<strong>实际测试.jpeg后缀文件更改为.jpg后缀依旧可读</strong>。</p><p>JPEG格式的压缩技术十分先进，<strong>能够将图像压缩在很小的储存空间</strong>，不过这种压缩是<strong>有损耗</strong>的，过度压缩会降低图片的质量。JPEG格式压缩的主要是高频信息，对色彩的信息保留较好，因此特别适合应用于互联网，可减少图像的传输和加载时间。</p><p>jpeg没有透明信息。<strong>jpeg比较适合用来存储相机拍出来的照片，这类图像用jpeg压缩后的体积比较小</strong>。其使用的具体算法核心是离散余弦变换、Huffman编码、算术编码等技术。</p><h2 id="png"><a href="#png" class="headerlink" title="png"></a>png</h2><p>全称<code>Portable Network Graphic Format</code>。<br>png 最重要的特点是<strong>支持alpha 通道透明度</strong>，也就是说，<strong>PNG图片支持透明背景</strong>。一般来说彩色图像是24位3通道图像，png格式的图像就是4通道的。</p><p>png的设计目的是试图替代gif和tiff。png是一种支持无损压缩的图像格式（从LZ77派生的无损数据压缩算法），没有可调整的压缩质量设置（有损程度）。虽然PNG提供的压缩量比JPEG少，但PNG图片却比JPEG图片有更小的文档尺寸，因此现在越来越多的网络图像开始采用PNG格式。</p><p><strong>jpeg比较适合存储色彩“杂乱”的拍摄图片，png比较适合存储几何特征强的图形类图片（颜色值少）</strong>。</p><h2 id="gif"><a href="#gif" class="headerlink" title="gif"></a>gif</h2><p>全称<code>Graphics Interchange Format</code>。<br>GIF也是一种压缩的图片格式，分为动态GIF和静态GIF两种。</p><p>GIF格式的最大特点是<strong>支持动态图片</strong>（多帧），并且支持透明背景。网络上绝大部分动图、表情包都是GIF格式的，相比与动画，GIF动态图片占用的存储空间小，加载速度快，因此非常流行。</p><h2 id="psd"><a href="#psd" class="headerlink" title="psd"></a>psd</h2><p>全称<code>Photoshop Document</code>。<br>PSD格式是Photoshop默认的存储格式，<strong>适用于存储源文档和工作文件</strong>，修改起来比较方便。<br>PSD格式的最大特点是可以保留透明度、图层、路径、通道等PS处理信息，但是需要专业的图形处理软件才能打开。PSD格式的缺点是体积庞大，十分占用存储空间。</p><h2 id="tiff"><a href="#tiff" class="headerlink" title="tiff"></a>tiff</h2><p>全称<code>Tagged Image File Format</code><br>，TIFF格式，也叫做或TIF格式，可以支持不同颜色模式、路径、透明度、以及通道，是打印文档中最常用的格式。Photoshop支持在TIFF文件中保存图层以及其他信息，在很多方面类似于PSD格式文件。</p><h2 id="bmp"><a href="#bmp" class="headerlink" title="bmp"></a>bmp</h2><p>全称<code>Bitmap</code>。<br>BMP 格式是Windows操作系统中的标准图像文件格式，能够被多种Windows应用程序所支持。BMP格式包含的图像信息较丰富，<strong>几乎不进行压缩</strong>，但由此导致了它占用的存储空间很大，所以，目前BMP在单机上比较流行。</p><h2 id="webp"><a href="#webp" class="headerlink" title="webp"></a>webp</h2><p>google开发的一种有损、透明图片格式，相当于jpeg和png的合体，google声称其可以把图片大小减少40%。但是当前支持差，压得慢。</p><h2 id="svg"><a href="#svg" class="headerlink" title="svg"></a>svg</h2><p>全称<code>Scalable Vector Graphics</code>，意思为可缩放的矢量图形。它是<strong>基于XML</strong>（Extensible Markup Language），由World Wide Web Consortium（W3C）联盟进行开发的。严格来说应该是一种开放标准的矢量图形语言，可让你设计激动人心的、高分辨率的Web图形页面。用户可以直接用代码来描绘图像，可以用任何文字处理工具打开SVG图像，通过改变部分代码来使图像具有交互功能，并可以随时插入到HTML中通过浏览器来观看。</p><p><img src="https://cdn.jsdelivr.net/gh/biggfish3147/pics/blog/ilF0003.jpg" alt="图像啊图像"></p><h1 id="图像的附加信息"><a href="#图像的附加信息" class="headerlink" title="图像的附加信息"></a>图像的附加信息</h1><h2 id="Exif信息"><a href="#Exif信息" class="headerlink" title="Exif信息"></a>Exif信息</h2><p>Exif <code>Exchangeable image file format</code>可交换图像文件格式，是<strong>专门为数码相机的照片设定的，可以记录数码照片的属性信息和拍摄数据</strong>。如米6拍摄的照片，照片文件详情中附带有拍摄参数，便是exif信息。Exif可以附加于JPEG、TIFF、RIFF等文件之中，为其增加有关数码相机拍摄信息的内容和索引图或图像处理软件的版本信息。</p><p>所有的JPEG文件以字符串“0xFFD8”开头，并以字符串“0xFFD9”结束。文件头中有一系列“0xFF??”格式的字符串，称为“标识”，用来标记JPEG文件的信息段。“0xFFD8”表示图像信息开始，“0xFFD9”表示图像信息结束，这两个标识后面没有信息，而其它标识紧跟一些信息字符。0xFFE0 – 0xFFEF之间的标识符称为“<strong>应用标记</strong>”，没有被常规JPEG文件利用，<strong>Exif正是利用这些信息串记录拍摄信息如快门速度、光圈值等，甚至可以包括全球定位信息。</strong></p><h2 id="隐私数据思考"><a href="#隐私数据思考" class="headerlink" title="隐私数据思考"></a>隐私数据思考</h2><p><strong>手机所拍的照片，在查看详情时可能看到地理位置信息，即拍摄地的经纬度坐标信息</strong>。通过经纬度坐标，利用百度的拾取坐标系统进行坐标反查，能够精准定位相片的拍摄地址。这里便思考到隐私数据的问题，如果拍摄的相片都附加这些地址信息，那是不是存在隐私泄露的问题。</p><p>于是我尝试将图片原图（包含地址信息）从手机QQ/微信传到电脑QQ/微信，图片另存为，查看图片详情（文件大小未变化），发现图像的拍摄参数及地址信息依旧能看到。进一步，我下载来自朋友圈和QQ动态的实拍图片（自己上传测试用的照片），并查看详细信息，拍摄参数以及地址信息均为空。</p><p>那么照片的exif信息是被脱敏了吗？还是我们的exif信息在特定的传输过程被丢弃（蓝牙传输文件exif信息仍存在）？当我们的原图上传到qq空间或朋友圈后，图片的存储位置在腾讯的数据中心，腾讯里的我们的照片已经不包含地址信息了吗？还是图片进一步有损压缩（提高网络传输效率）直接丢弃附属信息？</p><p>答案尚且确定不了。但知道一点，<strong>相机设置里可以关闭 保存地理位置信息 的选项</strong>。如此，原图没有位置信息，便不存在地址泄露的隐私问题了。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>大致整理一下，才发现枯燥的文字是真的多。收获就是大概知道web开发过程中为什么logo选择.svg或者.icon格式的矢量图，为什么一亿像素相机的相片用HEIF图片格式（米10高质量图片降低文件大小的解决方案），知道jpeg格式图片改动后保存会导致图片越来越小。</p><p>更重要的是知道这样一种观点：<font color="red">无论哪一种图片格式规范，其本质都是为了图像传输的高效或者图像的高质量，两者不可得兼</font>。没得最完美的，适合你需求的就是最好的选择。</p><h1 id="参考文献："><a href="#参考文献：" class="headerlink" title="参考文献："></a>参考文献：</h1><p><a href="https://www.coreldrawchina.com/xinshourumen/weitu-shiliangtu.html" target="_blank" rel="noopener">矢量图与位图的区别</a><br><a href="https://www.zhihu.com/question/21283005" target="_blank" rel="noopener">知乎：既然矢量图放大缩小都不失真，为什么还要使用位图？</a><br><a href="https://www.zhihu.com/question/20028452" target="_blank" rel="noopener">图片格式 jpg、png、gif各有什么优缺点？什么情况下用什么格式的图片呢？</a><br><a href="https://zhuanlan.zhihu.com/p/143649897" target="_blank" rel="noopener">几种常见图片格式的区别</a><br><a href="https://blog.csdn.net/jianzhengzhouzjz/article/details/7427432" target="_blank" rel="noopener">像素深度与图像深度</a><br><a href="https://blog.csdn.net/tz_zs/article/details/79768201" target="_blank" rel="noopener">二值图像、灰度图像、彩色图像</a><br><a href="https://juejin.im/post/5c8e4feb6fb9a070aa5ce200" target="_blank" rel="noopener">PNG图片压缩原理解析</a>  </p><p><img src="https://cdn.jsdelivr.net/gh/biggfish3147/pics/blog/ilF0013.jpg" alt="图像啊图像"></p>]]></content>
    
    <summary type="html">
    
      从图像分辨率到隐私数据的思考，需要知道的一些概念
    
    </summary>
    
    
      <category term="常识" scheme="http://yoursite.com/categories/%E5%B8%B8%E8%AF%86/"/>
    
    
      <category term="概念" scheme="http://yoursite.com/tags/%E6%A6%82%E5%BF%B5/"/>
    
      <category term="图像" scheme="http://yoursite.com/tags/%E5%9B%BE%E5%83%8F/"/>
    
      <category term="常识" scheme="http://yoursite.com/tags/%E5%B8%B8%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>Json基础</title>
    <link href="http://yoursite.com/2020/05/20/Json%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2020/05/20/Json%E5%9F%BA%E7%A1%80/</id>
    <published>2020-05-20T02:24:19.000Z</published>
    <updated>2020-10-12T08:14:10.339Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>JSON其实就是一种数据的表示格式，由于其自身的优点（XML衬托）而广泛用于前后端的<strong>文本数据交互</strong>。这里又大概能够窥见XML与JSON的暗流涌动，一如前述JSP的落寞，但不至于那么惨烈。目前XML格式的文件还广泛作为配置文件的格式存在，尽管<code>.yml</code>、<code>.properties</code>、<code>.json</code>文件也在某些地方作为配置文件的格式。</p><p>细想起来，无非也就是一种数据格式。编程圈里可能有很多“取代”这一说法，我并不十分认同，每种技术点自然有其存在的环境与背景，适时的发挥作用罢了。但技术的向前发展进步，是毋庸置疑的，所以我也不会无聊地选择用XML来做文本数据传输。突然想到，HTML的标签语法，是不是也存在着标签增加网络传输流量这一说法？又或者从JSON的命名看，是否前端巨头JavaScript就捧红了JSON呢？当然这是无端的幻想，技术时时刻刻都在迭代，我们唯有跟着大浪而已。</p><p><img src="https://cdn.jsdelivr.net/gh/biggfish3147/pics/blog/ilF1015.jpg" alt="地平线的余晖"></p><h1 id="Json简介"><a href="#Json简介" class="headerlink" title="Json简介"></a>Json简介</h1><p>JSON 是<strong>存储和交换文本信息</strong>的语法。类似 XML。JSON 比 XML 更小、更快，更易解析。</p><ul><li>JSON 指的是 JavaScript 对象表示法<code>JavaScript Object Notation</code></li><li>JSON 是<strong>轻量级的文本数据交换格式</strong></li><li>JSON 独立于语言</li><li>JSON 具有自我描述性，更易理解</li></ul><p>JSON 使用 <strong>JavaScript 语法</strong>来描述数据对象，但是 JSON 仍然独立于语言和平台。<strong>JSON 解析器和 JSON 库</strong>支持许多不同的编程语言（PHP、Java、Python中均可以使用JSON）。</p><p>JSON 文本格式在语法上与创建 JavaScript 对象的代码相同。由于这种相似性，无需解析器，JavaScript 程序能够使用<strong>内建的 eval() 函数</strong>，用 JSON 数据来生成原生的 JavaScript 对象。</p><p>注：JSON常用于<strong>前后端的数据交互</strong>（前端Ajax上传JSON数据，服务器返回JSON字符串），需要明确是<strong>文本数据</strong>，类似图片文件等不能通过JSON来传输。</p><h1 id="Json数据"><a href="#Json数据" class="headerlink" title="Json数据"></a>Json数据</h1><p>通过Js语法声明并初始化JSON对象，可以是单个JSON对象，也可以是JSON数组。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> JSONObject= &#123;</span><br><span class="line">    <span class="string">"name"</span>:<span class="string">"Bill Gates"</span>,</span><br><span class="line">    <span class="string">"street"</span>:<span class="string">"Fifth Avenue New York 666"</span>,</span><br><span class="line">    <span class="string">"age"</span>:<span class="number">56</span>,</span><br><span class="line">    <span class="string">"phone"</span>:<span class="string">"555 1234567"</span>&#125;;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//json数组，每个元素是一个对象    </span></span><br><span class="line"><span class="keyword">var</span> employees = [</span><br><span class="line">    &#123; <span class="string">"firstName"</span>:<span class="string">"Bill"</span> , <span class="string">"lastName"</span>:<span class="string">"Gates"</span> &#125;,</span><br><span class="line">    &#123; <span class="string">"firstName"</span>:<span class="string">"George"</span> , <span class="string">"lastName"</span>:<span class="string">"Bush"</span> &#125;,</span><br><span class="line">    &#123; <span class="string">"firstName"</span>:<span class="string">"Thomas"</span> , <span class="string">"lastName"</span>: <span class="string">"Carter"</span> &#125;</span><br><span class="line">];</span><br></pre></td></tr></table></figure><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><ul><li>数据在名称/值对中（<strong>双引号</strong>）</li><li>数据由<strong>逗号</strong>分隔</li><li>花括号保存对象</li><li>方括号保存数组</li></ul><h2 id="Json数据值"><a href="#Json数据值" class="headerlink" title="Json数据值"></a>Json数据值</h2><ul><li>数字（整数或浮点数）</li><li>字符串（在双引号中）</li><li>逻辑值（true 或 false）</li><li>数组（在方括号中）</li><li>对象（在花括号中）</li><li>null</li></ul><blockquote><p>注: Js的数据类型一般为6种，其中基本数据类型：字符串（String）、数字(Number)、布尔(Boolean)、空（Null）、未定义（Undefined），引用数据类型：对象(Object)，ES6中新增Symbol（独一无二的值）。可以通过 typeof 查看变量类型，数组(Array)返回object类型，函数(Function)返回function类型。</p></blockquote><h1 id="Json基本用法"><a href="#Json基本用法" class="headerlink" title="Json基本用法"></a>Json基本用法</h1><h2 id="把-JSON-文本转换为-JavaScript-对象"><a href="#把-JSON-文本转换为-JavaScript-对象" class="headerlink" title="把 JSON 文本转换为 JavaScript 对象"></a>把 JSON 文本转换为 JavaScript 对象</h2><p>JSON 最常见的用法之一，是<strong>从 web 服务器上读取 JSON 数据（作为文件或作为 HttpRequest），将 JSON 数据转换为 JavaScript 对象</strong>，然后在网页中使用该数据。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>通过 JSON 字符串来创建对象<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">First Name: <span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">"fname"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span> <span class="comment">&lt;!--显示Bill--&gt;</span></span><br><span class="line">Last Name: <span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">"lname"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span> <span class="comment">&lt;!--显示Gates--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="actionscript"><span class="keyword">var</span> txt = <span class="string">'&#123;"employees":['</span> +</span></span><br><span class="line"><span class="actionscript"><span class="string">'&#123;"firstName":"Bill","lastName":"Gates" &#125;,'</span> +</span></span><br><span class="line"><span class="actionscript"><span class="string">'&#123;"firstName":"George","lastName":"Bush" &#125;,'</span> +</span></span><br><span class="line"><span class="actionscript"><span class="string">'&#123;"firstName":"Thomas","lastName":"Carter" &#125;]&#125;'</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> obj = <span class="built_in">eval</span> (<span class="string">"("</span> + txt + <span class="string">")"</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.getElementById(<span class="string">"fname"</span>).innerHTML=obj.employees[<span class="number">1</span>].firstName </span></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.getElementById(<span class="string">"lname"</span>).innerHTML=obj.employees[<span class="number">1</span>].lastName </span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="JSON解析器"><a href="#JSON解析器" class="headerlink" title="JSON解析器"></a>JSON解析器</h2><p>eval() 函数可编译并执行任何 JavaScript 代码。  </p><p>使用 JSON 解析器将 JSON 转换为 JavaScript 对象是更安全的做法。<strong>JSON 解析器只能识别 JSON 文本，而不会编译脚本</strong>。</p><p>在浏览器中，这提供了原生的 JSON 支持，而且 JSON 解析器的速度更快。</p><p><img src="https://cdn.jsdelivr.net/gh/biggfish3147/pics/blog/ilF1020.jpg" alt="行走在街头"></p><h1 id="Json应用示例"><a href="#Json应用示例" class="headerlink" title="Json应用示例"></a>Json应用示例</h1><p>从<strong>前端的视角</strong>来解读JSON用法，包括如何将服务端的JSON字符串解析为JSON对象，以及如何将JSON对象转换为JSON字符串传递给服务端。</p><h2 id="JSON-parse"><a href="#JSON-parse" class="headerlink" title="JSON.parse()"></a>JSON.parse()</h2><p>JSON 通常用于与服务端交换数据。前端接收服务器数据时一般是获得字符串。</p><p>我们可以使用 JSON.parse() 方法将JSON字符串数据转换为 JavaScript 对象。</p><p><strong>语法：JSON.parse(text, [reviver])</strong></p><p>reviver:&emsp;一个转换结果的函数， 将为对象的每个成员调用此函数。</p><ul><li>从服务端接收json数据</li><li>从服务端接收数组的json数据</li><li>解析日期</li><li>解析函数（将函数作为字符串存储，<strong>不建议在json中使用函数</strong>）</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>菜鸟教程(runoob.com)<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>字符串转换为 Date 对象<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"demo"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript"><span class="comment">//案例：可选参数reviver的使用（一般为函数）</span></span></span><br><span class="line"></span><br><span class="line"><span class="actionscript"><span class="keyword">var</span> text = <span class="string">'&#123; "name":"Runoob", "initDate":"2013-12-14", "site":"www.runoob.com"&#125;'</span>;</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> obj = <span class="built_in">JSON</span>.parse(text, <span class="function"><span class="keyword">function</span> (<span class="params">key, value</span>) </span>&#123;</span></span><br><span class="line"><span class="actionscript"><span class="keyword">if</span> (key == <span class="string">"initDate"</span>) &#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>(value);</span></span><br><span class="line"><span class="actionscript">&#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">return</span> value;</span></span><br><span class="line">&#125;&#125;);</span><br><span class="line"></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.getElementById(<span class="string">"demo"</span>).innerHTML = obj.name + <span class="string">"创建日期："</span> + obj.initDate;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="JSON-stringify"><a href="#JSON-stringify" class="headerlink" title="JSON.stringify()"></a>JSON.stringify()</h2><p>JSON 通常用于与服务端交换数据。在<strong>向服务器发送数据时一般是字符串</strong>。</p><p>我们可以使用 JSON.stringify() 方法将 JavaScript 对象转换为字符串。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>菜鸟教程(runoob.com)<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>将 JavaScript 对象转换为 JSON 字符串<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"demo"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript"><span class="keyword">var</span> obj = &#123; <span class="string">"name"</span>:<span class="string">"runoob"</span>, <span class="string">"alexa"</span>:<span class="number">10000</span>, <span class="string">"site"</span>:<span class="string">"www.runoob.com"</span>&#125;;</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> myJSON = <span class="built_in">JSON</span>.stringify(obj);</span></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.getElementById(<span class="string">"demo"</span>).innerHTML = myJSON;</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript"><span class="comment">//上述两句替换后测试</span></span></span><br><span class="line"><span class="actionscript"><span class="comment">//document.getElementById("demo").innerHTML = obj;</span></span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="Java中使用JSON"><a href="#Java中使用JSON" class="headerlink" title="Java中使用JSON"></a>Java中使用JSON</h1><p>Java中并没有内置JSON的解析，因此使用JSON需要借助第三方类库。常用的如Gson、FastJson、Jackson。</p><p>编码：从Java变量到JSON格式的编码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//以FastJson为例</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testJson</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    JSONObject object = <span class="keyword">new</span> JSONObject();</span><br><span class="line">    <span class="comment">//string</span></span><br><span class="line">    object.put(<span class="string">"string"</span>,<span class="string">"string"</span>);</span><br><span class="line">    <span class="comment">//int</span></span><br><span class="line">    object.put(<span class="string">"int"</span>,<span class="number">2</span>);</span><br><span class="line">    <span class="comment">//boolean</span></span><br><span class="line">    object.put(<span class="string">"boolean"</span>,<span class="keyword">true</span>);</span><br><span class="line">    <span class="comment">//array</span></span><br><span class="line">    List&lt;Integer&gt; integers = Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">    object.put(<span class="string">"list"</span>,integers);</span><br><span class="line">    <span class="comment">//null</span></span><br><span class="line">    object.put(<span class="string">"null"</span>,<span class="keyword">null</span>);</span><br><span class="line">​</span><br><span class="line">    System.out.println(object);</span><br><span class="line">    <span class="comment">//&#123;"boolean":true,"string":"string","list":[1,2,3],"int":2&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解码：从 JSON 对象到 Java 变量的解码过程</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testJson2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">​</span><br><span class="line">  JSONObject object = JSONObject</span><br><span class="line">      .parseObject(<span class="string">"&#123;\"boolean\":true,\"string\":\"string\",\"list\":[1,2,3],\"int\":2&#125;"</span>);</span><br><span class="line">  <span class="comment">//string</span></span><br><span class="line">  String s = object.getString(<span class="string">"string"</span>);</span><br><span class="line">  System.out.println(s);</span><br><span class="line">  <span class="comment">//int</span></span><br><span class="line">  <span class="keyword">int</span> i = object.getIntValue(<span class="string">"int"</span>);</span><br><span class="line">  System.out.println(i);</span><br><span class="line">  <span class="comment">//boolean</span></span><br><span class="line">  <span class="keyword">boolean</span> b = object.getBooleanValue(<span class="string">"boolean"</span>);</span><br><span class="line">  System.out.println(b);</span><br><span class="line">  <span class="comment">//list</span></span><br><span class="line">  List&lt;Integer&gt; integers = JSON.parseArray(object.getJSONArray(<span class="string">"list"</span>).toJSONString(),Integer.class);</span><br><span class="line">  integers.forEach(System.out::println);</span><br><span class="line">  <span class="comment">//null</span></span><br><span class="line">  System.out.println(object.getString(<span class="string">"null"</span>));</span><br><span class="line">​   </span><br><span class="line">  <span class="comment">//输出</span></span><br><span class="line">  <span class="comment">//string</span></span><br><span class="line">  <span class="comment">//2</span></span><br><span class="line">  <span class="comment">//true</span></span><br><span class="line">  <span class="comment">// 1</span></span><br><span class="line">  <span class="comment">// 2</span></span><br><span class="line">  <span class="comment">// 3</span></span><br><span class="line">  <span class="comment">// null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JSON对象与字符串的相互转化</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//从字符串解析JSON对象</span></span><br><span class="line">JSONObject obj = JSON.parseObject(<span class="string">"&#123;\"runoob\":\"菜鸟教程\"&#125;"</span>);</span><br><span class="line"><span class="comment">//从字符串解析JSON数组</span></span><br><span class="line">JSONArray arr = JSON.parseArray(<span class="string">"[\"菜鸟教程\",\"RUNOOB\"]\n"</span>);</span><br><span class="line"><span class="comment">//将JSON对象转化为字符串</span></span><br><span class="line">String objStr = JSON.toJSONString(obj);</span><br><span class="line"><span class="comment">//将JSON数组转化为字符串</span></span><br><span class="line">String arrStr = JSON.toJSONString(arr);</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.runoob.com/json/json-tutorial.html" target="_blank" rel="noopener">菜鸟：JSON教程</a></p><p><img src="https://cdn.jsdelivr.net/gh/biggfish3147/pics/blog/ilR0003.jpg" alt="平凡的一天"></p>]]></content>
    
    <summary type="html">
    
      前后端文本数据交互，跨平台跨语言的JSON
    
    </summary>
    
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="概念" scheme="http://yoursite.com/tags/%E6%A6%82%E5%BF%B5/"/>
    
      <category term="Json" scheme="http://yoursite.com/tags/Json/"/>
    
      <category term="数据传输" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93/"/>
    
  </entry>
  
  <entry>
    <title>漫谈JSP</title>
    <link href="http://yoursite.com/2020/05/09/%E6%BC%AB%E8%B0%88JSP/"/>
    <id>http://yoursite.com/2020/05/09/%E6%BC%AB%E8%B0%88JSP/</id>
    <published>2020-05-09T10:39:19.000Z</published>
    <updated>2020-10-12T08:13:56.306Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>以前倒是知道<code>JSP</code>概念，但只能算是大概中的大概。今天因缘际会，又大致去查了些资料，然后就知道了个大概。比起<code>JSP</code>本身的语法规则，我对其由盛及衰的发展历史，倒表现出更大的兴趣。</p><p><img src="https://cdn.jsdelivr.net/gh/biggfish3147/pics/blog/ship.jpg" alt="古堡小船"></p><h1 id="JSP"><a href="#JSP" class="headerlink" title="JSP"></a>JSP</h1><p>全称<code>JavaServer Pages</code>，即Java服务器页面。它是一种 <strong>动态</strong> 网页技术标准，是一种服务器端的脚本语言（以<code>Java</code>作为脚本语言），但却和<code>PHP</code> <code>ASP</code>有着本质的区别，JSP本质上就是一种<code>Java Servlet</code>。</p><p>JSP技术使用JSP标签在HTML网页中插入Java代码，也就是将Java代码和特定变动内容嵌入到静态的页面中，实现以静态页面为模板，动态生成其中的部分内容。标签通常以&lt;%开头，以%&gt;结束。</p><p>JSP标签有多种功能，比如访问数据库、访问JavaBeans组件等，还可以在不同的网页中传递控制信息和共享信息。</p><h2 id="语法标准"><a href="#语法标准" class="headerlink" title="语法标准"></a>语法标准</h2><p>一个JSP页面可以被分为以下几部分：</p><ul><li>静态数据，如HTML</li><li>JSP指令，如include指令</li><li>JSP脚本元素（标签）和变量，如脚本变量request </li><li>JSP动作，如jsp:forward</li><li>用户自定义标签</li></ul><h2 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h2><p>通常我们在JSP文件中写Html代码，于是<strong>在使用上</strong>可以把它当作Html文件。比如我们访问某个网站的首页<code>http://yourdomainname:8080/index.jsp</code>，请求的就是这个JSP文件，这里理解上就可以认为JSP文件是一种<strong>动态资源</strong>（<code>Html/CSS</code>文件、图片等属于静态资源）。</p><p>当用户请求JSP文件时，服务器内部会经历一次JSP（动态资源）到HTML（静态资源）的转换，服务器会自动帮我们把JSP中的HTML片段和数据拼接成静态资源响应给浏览器。</p><p>网络服务器需要一个 JSP 引擎，也就是一个容器来处理 JSP 页面。容器负责截获对 JSP页面的请求。也就是说，<strong>JSP文件是运行在服务端</strong>而不是客户端的。</p><ul><li>JSP转换为Servlet</li></ul><p>JSP文件在运行时会被JSP引擎（引擎<code>jspServlet</code>本身也是Servlet，负责解释和执行JSP页面）转换成更原始的Servlet代码（.java后缀即java源文件）。在转换时，如果发现JSP文件中有任何语法错误，则中断转换过程，并向服务端和客户端输出错误信息。</p><blockquote><p>注:servlet是用Java语言编写的服务器端程序。主要功能是和浏览器进行交互，生成页面展示。</p></blockquote><ul><li>转换为.class文件</li></ul><p>JSP被JSP引擎转换为Servlet后，将被编译成Servlet的class文件（字节码文件）。也就是通常的.java文件到.class文件的编译过程。</p><ul><li>Servlet容器处理</li></ul><p>.jsp文件转换之后的.class文件能够被JVM（Java虚拟机）执行，通过加载类、初始化、实例化等步骤，将执行结果（Html代码-静态文件）传递给（处理这个jsp请求的Servlet程序中的）response对象，进而通过Web服务器响应给浏览器。</p><ul><li>浏览器解析Html</li></ul><p>浏览器只能够处理并渲染静态资源。虽然请求的是.jsp文件，但是获得的响应是完完全全的Html文件，于是解析Html代码并将请求的页面显示。</p><h2 id="JSP、PHP与ASP"><a href="#JSP、PHP与ASP" class="headerlink" title="JSP、PHP与ASP"></a>JSP、PHP与ASP</h2><ul><li>PHP  </li></ul><p>PHP是一种嵌入HTML页面中的脚本语言，使Web开发者能够快速地写出动态产生页面。</p><p>PHP语法简单，非常易学易用，很利于快速开发各种功能不同的定制网站（<code>APACHE＋PHP＋MYSQL</code>搭配），但因为结构上的缺陷，使的PHP在复杂的大型项目上的开发和维护都比较困难。</p><ul><li>ASP</li></ul><p>ASP（Active Server Pages）是微软的Windows IIS系统自带的脚本语言，利用它可以执行动态的Web服务应用程序。</p><p>和PHP一样，ASP简单而易于维护，很适合小型网站应用，通过DCOM和MTS技术，ASP甚至还可以完成小规模的企业应用，但ASP的致命缺点就是不支持跨平台的系统，在大型项目开发和维护上非常困难。</p><ul><li>JSP</li></ul><p>JSP（JavaServer Pages）是Sun公司推出的一种动态网页技术。JSP本身虽然也是脚本语言(以Java作为脚本语言)，但是却和PHP、ASP有着本质的区别。PHP和ASP都是由语言引擎解释执行程序代码，而JSP代码却被编译成Servlet并由Java虚拟机执行，这种编译操作仅在对JSP页面的第一次请求时发生。因此普遍认为JSP的执行效率比PHP和ASP都高。</p><p>JSP是一种服务器端的脚本语言，最大的好处就是开发效率较高，但是因为其业务规则代码与页面代码混为一团，不利于维护，因此并不适应大型应用的要求，取而代之的是基于MVC的Web架构。</p><p>MVC的核心思想是将应用分为模型、视图和控制器三部分。模型是指应用程序的数据，以及对这些数据的操作；视图是指用户界面；控制器负责用户界面和程序数据之间的同步。通过MVC的Web架构，可以弱化各个部分的耦合关系，并将业务逻辑处理与页面以及数据分离开来，这样当其中一个模块的代码发生改变时，并不影响其他模块的正常运行，所以基于MVC的Web架构更适应于大型应用开发的潮流。</p><p><img src="https://cdn.jsdelivr.net/gh/biggfish3147/pics/blog/planet.jpg" alt="星球"></p><h1 id="由盛及衰"><a href="#由盛及衰" class="headerlink" title="由盛及衰"></a>由盛及衰</h1><h2 id="故事背景"><a href="#故事背景" class="headerlink" title="故事背景"></a>故事背景</h2><p>1995年，SUN公司发布了Java。创始人之一望着手中的咖啡，灵机一动，取名Java。宣传口号是”一次编写，到处运行”（Write Once, Run Anywhere）。</p><blockquote><p>注：一次编写，到处运行，也就是跨平台了。</p></blockquote><p>几乎同年，后来被黑为“世界上最好的语言”PHP也发布了。WordPress和MediaWiki就是有出息的两个儿子。</p><p>也是1995年，一个名叫布兰登·艾奇的技术员，为应付任务花了10天设计出JavaScript（这名字就是蹭Java热度，JavaScript与Java只有半毛钱关系）。这个借鉴C、Java、Scheme和Self等语言设计出来的冬冬，初始版本很不好用，但好在后期救回来了，并逐渐走上人生巅峰。</p><blockquote><p>注：一个完整的JavaScript实现应由三个部分组成:ECMAScript、DOM、BOM</p></blockquote><h2 id="出道往事"><a href="#出道往事" class="headerlink" title="出道往事"></a>出道往事</h2><h3 id="黑世纪–Servlet写Html代码"><a href="#黑世纪–Servlet写Html代码" class="headerlink" title="黑世纪–Servlet写Html代码"></a>黑世纪–Servlet写Html代码</h3><p>下述是MyEclipse新建Servlet时显示的模板。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HistoryServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructor of the object.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HistoryServlet</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Destruction of the servlet. &lt;br&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>.destroy(); <span class="comment">// Just puts "destroy" string in log</span></span><br><span class="line"><span class="comment">// Put your code here</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The doGet method of the servlet. &lt;br&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This method is called when a form has its tag value method equals to get.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> request the request send by the client to the server</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> response the response send by the server to the client</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> ServletException if an error occurred</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException if an error occurred</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">response.setContentType(<span class="string">"text/html"</span>);</span><br><span class="line">PrintWriter out = response.getWriter();</span><br><span class="line">out.println(<span class="string">"&lt;!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\"&gt;"</span>);</span><br><span class="line">out.println(<span class="string">"&lt;HTML&gt;"</span>);</span><br><span class="line">out.println(<span class="string">"  &lt;HEAD&gt;&lt;TITLE&gt;A Servlet&lt;/TITLE&gt;&lt;/HEAD&gt;"</span>);</span><br><span class="line">out.println(<span class="string">"  &lt;BODY&gt;"</span>);</span><br><span class="line">out.print(<span class="string">"    This is "</span>);</span><br><span class="line">out.print(<span class="keyword">this</span>.getClass());</span><br><span class="line">out.println(<span class="string">", using the GET method"</span>);</span><br><span class="line">out.println(<span class="string">"  &lt;/BODY&gt;"</span>);</span><br><span class="line">out.println(<span class="string">"&lt;/HTML&gt;"</span>);</span><br><span class="line">out.flush();</span><br><span class="line">out.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The doPost method of the servlet. &lt;br&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This method is called when a form has its tag value method equals to post.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> request the request send by the client to the server</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> response the response send by the server to the client</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> ServletException if an error occurred</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException if an error occurred</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">response.setContentType(<span class="string">"text/html"</span>);</span><br><span class="line">PrintWriter out = response.getWriter();</span><br><span class="line">out.println(<span class="string">"&lt;!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\"&gt;"</span>);</span><br><span class="line">out.println(<span class="string">"&lt;HTML&gt;"</span>);</span><br><span class="line">out.println(<span class="string">"  &lt;HEAD&gt;&lt;TITLE&gt;A Servlet&lt;/TITLE&gt;&lt;/HEAD&gt;"</span>);</span><br><span class="line">out.println(<span class="string">"  &lt;BODY&gt;"</span>);</span><br><span class="line">out.print(<span class="string">"    This is "</span>);</span><br><span class="line">out.print(<span class="keyword">this</span>.getClass());</span><br><span class="line">out.println(<span class="string">", using the POST method"</span>);</span><br><span class="line">out.println(<span class="string">"  &lt;/BODY&gt;"</span>);</span><br><span class="line">out.println(<span class="string">"&lt;/HTML&gt;"</span>);</span><br><span class="line">out.flush();</span><br><span class="line">out.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Initialization of the servlet. &lt;br&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> ServletException if an error occurs</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line"><span class="comment">// Put your code here</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上古时代，就是这样一行一行写入Html代码到response对象中的。美工做好Html的静态页面，扔给Java程序员。Java程序员逐条拷贝Html代码，并于后端数据拼接，最后返回带数据的完整的Html。</p><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">out</span>.println("&lt;span&gt;用户名："+<span class="keyword">user</span>.name+&lt;"/span&gt;");</span><br></pre></td></tr></table></figure><h3 id="出道–Servlet披着JSP的壳"><a href="#出道–Servlet披着JSP的壳" class="headerlink" title="出道–Servlet披着JSP的壳"></a>出道–Servlet披着JSP的壳</h3><p>友商PHP这时候就很优秀，它们选择在html页面中嵌入相应语言来引入动态数据。</p><p>细想起来，目标无非就是在最终输出的html的代码中嵌入后台数据。可以在Html文件中嵌入动态数据，也可以在动态页面中嵌入Html静态数据，殊途同归。</p><p>于是，JSP诞生了。虽然名字叫做JSP，但JSP实质上就是Servlet实例。暗世纪手动拷贝HTML代码的日子结束了，这些操作交给了JSP引擎（即jspServlet）去执行。</p><p>JSP = Html + Java片段。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">%@</span> <span class="attr">page</span> <span class="attr">language</span>=<span class="string">"java"</span> <span class="attr">contentType</span>=<span class="string">"text/html;charset=UTF-8"</span></span></span><br><span class="line"><span class="tag"><span class="attr">pageEncoding</span>=<span class="string">"UTF-8"</span>%&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">%@</span> <span class="attr">page</span> <span class="attr">import</span>=<span class="string">"com.py.vo.Member"</span>%&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">%</span></span></span><br><span class="line"><span class="tag"><span class="attr">String</span> <span class="attr">path</span> = <span class="string">request.getContextPath();</span></span></span><br><span class="line"><span class="tag"><span class="attr">String</span> <span class="attr">basePath</span> = <span class="string">request.getScheme()+</span>"<span class="attr">:</span>//"+<span class="attr">request.getServerName</span>()+"<span class="attr">:</span>"+<span class="attr">request.getServerPort</span>()+<span class="attr">path</span>+"/";</span></span><br><span class="line"><span class="tag">%&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">xmlns</span>=<span class="string">"http://www.w3.org/1999/xhtml"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">base</span> <span class="attr">href</span>=<span class="string">"&lt;%=basePath%&gt;"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>电子商务网站<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"css/style.css"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">type</span>=<span class="string">"text/css"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript"><span class="function"><span class="keyword">function</span> <span class="title">quit</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript"><span class="keyword">if</span> (confirm(<span class="string">"没有要买的东西了吗？"</span>)) &#123;</span></span><br><span class="line"><span class="javascript"><span class="built_in">window</span>.location.href = <span class="string">"MemberServlet.do?method=logoutMember"</span>;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"header"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"logo"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"index.jsp"</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"images/logo.gif"</span> <span class="attr">width</span>=<span class="string">"135"</span></span></span><br><span class="line"><span class="tag"><span class="attr">height</span>=<span class="string">"55"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">name</span>=<span class="string">"form"</span> <span class="attr">method</span>=<span class="string">"post"</span></span></span><br><span class="line"><span class="tag"><span class="attr">action</span>=<span class="string">"GoodsServlet.do?method=selectByKeywords"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"search"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">class</span>=<span class="string">"input1"</span> <span class="attr">name</span>=<span class="string">"keywords"</span>/&gt;</span> <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"image"</span></span></span><br><span class="line"><span class="tag"><span class="attr">src</span>=<span class="string">"images/icon_search.gif"</span> <span class="attr">class</span>=<span class="string">"input2"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">%</span></span></span><br><span class="line"><span class="tag"><span class="attr">if</span> (<span class="attr">session.getAttribute</span>("<span class="attr">member</span>") == <span class="string">null)</span> &#123;</span></span><br><span class="line"><span class="tag">%&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"login"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"fg-memberLogin.jsp"</span> <span class="attr">class</span>=<span class="string">"a1"</span>&gt;</span>登录<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">%</span></span></span><br><span class="line"><span class="tag">&#125; <span class="attr">else</span> &#123;</span></span><br><span class="line"><span class="tag"><span class="attr">Member</span> <span class="attr">member</span> = <span class="string">(Member)</span> <span class="attr">session.getAttribute</span>("<span class="attr">member</span>");</span></span><br><span class="line"><span class="tag">%&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"login"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">font</span> <span class="attr">class</span>=<span class="string">"red"</span>&gt;</span><span class="tag">&lt;<span class="name">%=member.getAccount()%</span>&gt;</span><span class="tag">&lt;/<span class="name">font</span>&gt;</span>，欢迎回来&amp;nbsp;&amp;nbsp;<span class="tag">&lt;<span class="name">a</span></span></span><br><span class="line"><span class="tag"><span class="attr">href</span>=<span class="string">"javascript:quit()"</span>&gt;</span>退出<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">%</span></span></span><br><span class="line"><span class="tag">&#125;</span></span><br><span class="line"><span class="tag">%&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>JSP特点</p><ul><li>跨平台（以Java作为脚本）</li><li>业务代码分离（数据对象模型）</li><li>组件重用（JavaBean）</li><li>预编译（首次请求JSP是编译执行后，class文件被保存）</li></ul><h3 id="危机–优点也会是缺点"><a href="#危机–优点也会是缺点" class="headerlink" title="危机–优点也会是缺点"></a>危机–优点也会是缺点</h3><p>JSP文件能够同时写Html和Java，但是。</p><ol><li><p>动态和静态资源放在一起，一旦服务器出现状况，前后台一起玩完，用户体验极差。</p></li><li><p>一旦jsp出现了问题，就需要前端后端发开人员一块来分析解决，效率低。</p></li><li><p>jsp无法使用nginx等。</p></li><li><p>jsp页面复杂，难以修改。</p></li><li><p>第一次加载jsp需要编译成servlet，时间久，而且业务量大的时候，jsp负担太大。</p></li></ol><p>于是，前后端分离就出现了。</p><h3 id="落寞–前后端分离燃烧起来"><a href="#落寞–前后端分离燃烧起来" class="headerlink" title="落寞–前后端分离燃烧起来"></a>落寞–前后端分离燃烧起来</h3><p>前后端分离其实就是后端工程师只关注于后端业务逻辑的开发，不再处理前端问题。前端工程师只关注于自己的页面开发。需要数据交互的时候，两者会有一份接口文档。</p><p>然后新兴SpringMVC、RestFul、Ajax …</p><blockquote><p>注：MVC是WEB开发模式，并不是SpringMVC专属</p></blockquote><p>然后前端也不再是Web页面，移动端又蓬勃起来…</p><p>JSP也就这样渐渐的完成它的时代使命，告别曾经辉煌过的舞台，偶尔在一些老旧的项目中散发着微光…</p><h1 id="我的小结"><a href="#我的小结" class="headerlink" title="我的小结"></a>我的小结</h1><p>JSP的盛衰似乎令人唏嘘，但这就是技术的发展与进步。它已经完成了它的使命，但这并不意味着JSP应该被描述过时或者应该被抛弃，在适当的场景JSP还是有用武之地的，就像PHP依然那么活跃。</p><p>具体的JSP技术与语法，是现在的我不需要去花时间看的。近来觉得编程里边的知识很丰富，面面俱到不大现实也不应该。可以知道很多，但是专注的点也就只能那么几个。正所谓涉猎广泛，重点捕捉。</p><p>然后就是觉得学习编程不再纯粹只是看技术细节，还需要提升一点看语言的设计以及系统的整体架构。当然我现在还不会，就怎么说呢，技术是看代码和写代码，思想是像写诗一样优雅的造轮子。</p><p>胡言胡语，小结完毕。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://zhuanlan.zhihu.com/p/42343690" target="_blank" rel="noopener">知乎：浅谈JSP</a><br><a href="https://baijiahao.baidu.com/s?id=1645273953613115391&wfr=spider&for=pc" target="_blank" rel="noopener">曾经风光无限的jsp，为什么现在很少有人用了呢？</a><br><a href="https://www.cnblogs.com/lixuwu/articles/4499883.html" target="_blank" rel="noopener">php与jsp的区别</a><br><a href="https://zhuanlan.zhihu.com/p/71937497" target="_blank" rel="noopener">再见，JSP</a></p><p><img src="https://cdn.jsdelivr.net/gh/biggfish3147/pics/blog/yellowman.jpg" alt="小黄人"></p>]]></content>
    
    <summary type="html">
    
      JSP盛与衰的历史
    
    </summary>
    
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="概念" scheme="http://yoursite.com/tags/%E6%A6%82%E5%BF%B5/"/>
    
      <category term="JSP" scheme="http://yoursite.com/tags/JSP/"/>
    
  </entry>
  
  <entry>
    <title>Hexo与GitHub Pages搭建独立博客</title>
    <link href="http://yoursite.com/2020/04/29/%E6%90%AD%E5%BB%BA%E7%8B%AC%E7%AB%8B%E5%8D%9A%E5%AE%A2/"/>
    <id>http://yoursite.com/2020/04/29/%E6%90%AD%E5%BB%BA%E7%8B%AC%E7%AB%8B%E5%8D%9A%E5%AE%A2/</id>
    <published>2020-04-28T16:00:00.000Z</published>
    <updated>2020-04-29T11:22:54.998Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>博客其实在很久之前按照教程已经搭建完成，现在才回头来写教程步骤。有时候会想是否多此一举，毕竟网上现成的优秀的教程比比皆是。所以权且不说这是搭建基于Hexo的博客教程，只是一个简单的记录。</p><p>写一点东西，像擦肩而过的风。</p><p><img src="https://cdn.jsdelivr.net/gh/biggfish3147/pics/blog/7.jpg" alt="起飞"></p><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="GitHub-Pages"><a href="#GitHub-Pages" class="headerlink" title="GitHub Pages"></a>GitHub Pages</h2><p><code>GitHub Pages</code> 是一项<strong>静态站点托管服务</strong>，它直接从<code>GitHub</code> 上的仓库获取<code>HTML</code>、<code>CSS</code>和<code>JavaScript</code>文件，（可选）通过构建过程运行文件，然后发布网站。</p><p>有三种类型的 <code>GitHub Pages</code> 站点：项目、用户和组织。 项目站点连接到 <code>GitHub</code> 上托管的特定项目，用户和组织站点连接到特定的 <code>GitHub</code> 帐户。只能为每个 <code>GitHub</code>账户创建一个用户或组织站点。项目站点（无论是组织还是用户帐户拥有）没有限制。除非使用自定义域，否则用户和组织站点位于<code>http(s)://&lt;username&gt;.github.io</code> 或 <code>http(s)://&lt;organization&gt;.github.io</code>。</p><p>基于<code>GitHub Pages</code>搭建个人独立博客，即属于用户或组织站点。</p><p><code>GitHub Pages</code> 站点的发布来源是存储站点源文件的分支或文件夹。 所有站点都有默认的发布来源，项目站点还有其他可用的发布来源。用户和组织站点的默认发布来源是<code>master</code>分支。如果用户和组织站点的仓库是<code>master</code> 分支，您的站点将从该分支自动发布。无法为用户或组织站点选择不同的发布来源。</p><p><code>GitHub Pages</code> 站点受到以下使用限制的约束：</p><ul><li><code>GitHub Pages</code> 源仓库建议的限制为1GB。</li><li>发布的 <code>GitHub Pages</code> 站点不得超过 1 GB。</li><li><code>GitHub Pages</code> 站点的软带宽限制为每月 100GB。</li><li><code>GitHub Pages</code> 站点的软限制为每小时 10 次构建。</li></ul><h2 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h2><p><code>Hexo</code>是基于<code>Node.js</code>的快速、简洁且高效的博客框架。<code>Hexo</code> 使用 <code>Markdown</code>（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p><h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><ul><li>安装<code>Node.js</code></li><li>安装<code>Git</code></li><li>安装<code>Hexo</code><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//进入自己的博客文件夹(如/biggfish/blog)</span></span><br><span class="line">npm install hexo-cli -g </span><br><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure></li></ul><h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><ul><li><p>初始化配置</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在Hexo安装目录下新建hexo文件夹，如 /biggfish/blog/hexo</span></span><br><span class="line">hexo inint</span><br></pre></td></tr></table></figure></li><li><p>本地生成与部署</p><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在hexo文件目录下执行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//生成静态文件</span></span><br><span class="line">hexo <span class="keyword">generate</span>  </span><br><span class="line"></span><br><span class="line"><span class="comment">//本地部署</span></span><br><span class="line">hexo server </span><br><span class="line"></span><br><span class="line"><span class="comment">//本地测试</span></span><br><span class="line">http:<span class="comment">//localhost:4000/</span></span><br></pre></td></tr></table></figure></li><li><p>配置<code>Hexo</code>与远程<code>GitHub</code>仓库关联</p><figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建`GitHub Pages`的站点发布来源，即username.github.io仓库</span></span><br><span class="line"><span class="comment">//配置远程连接的SSH密钥与公钥</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//将本地Hexo文件（静态网页）更新到GitHub 的username.github.io仓库</span></span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 复制Github仓库的ssh地址</span><br><span class="line"><span class="number">2.</span> 选择hexo文件夹下_config.yml文件，修改deploy相关信息</span><br><span class="line"><span class="symbol">  deploy:</span></span><br><span class="line"><span class="symbol">    type:</span> git</span><br><span class="line"><span class="symbol">    repository:</span> 刚复制的仓库ssh地址</span><br><span class="line"><span class="symbol">    branch:</span> master</span><br></pre></td></tr></table></figure></li><li><p>本地博客推送到远程仓库，<code>GitHub Pages</code>自动发布</p><figure class="highlight stata"><table><tr><td class="code"><pre><span class="line"><span class="comment">//g-&gt;generate  d-&gt;deploy</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//生成静态文件，然后部署</span></span><br><span class="line">hexo <span class="keyword">g</span></span><br><span class="line">hexo <span class="built_in">d</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//或者联合执行</span></span><br><span class="line">hexo <span class="keyword">g</span> -<span class="built_in">d</span></span><br></pre></td></tr></table></figure></li><li><p>访问博客 <a href="https://biggfish3147.github.io" target="_blank" rel="noopener">我的博客</a></p></li></ul><h1 id="发表文章"><a href="#发表文章" class="headerlink" title="发表文章"></a>发表文章</h1><p>注意用<code>markdown</code>语法编写文章。</p><ul><li><p><code>Front-matter</code>配置</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">博客伊始</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2019</span><span class="bullet">-09</span><span class="bullet">-20</span> <span class="number">23</span><span class="string">:29:47</span></span><br><span class="line"><span class="attr">comments:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">tags:</span> <span class="string">随笔</span></span><br><span class="line"><span class="attr">categories:</span> <span class="string">随笔</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">君不见，黄河之水天上来，奔流到海不复回</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 文章正文</span></span><br><span class="line"></span><br><span class="line"><span class="string">注:</span> <span class="string">Front-matter配置支持的变量，其值因主题不同而存在差异</span></span><br><span class="line"><span class="string">/**</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">layout:</span> <span class="string">页面布局（配合主题文档使用）</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">文章名称</span></span><br><span class="line"><span class="attr">date:</span> <span class="string">文章日期</span></span><br><span class="line"><span class="attr">comments:</span> <span class="string">文章是否开启评论</span></span><br><span class="line"><span class="attr">photos:</span> <span class="string">文章封面图（仅部分主题支持）</span></span><br><span class="line"><span class="attr">tags:</span> </span><br><span class="line"><span class="bullet">  -</span> <span class="string">文章标签一</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">文章标签二</span></span><br><span class="line"><span class="attr">categories:</span> <span class="string">文章分类</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">文章描述，即要在首页显示的摘要（仅部分主题支持）</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="string">*/</span></span><br></pre></td></tr></table></figure></li><li><p>推送文章</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//.md文章保存在/biggfish/blog/hexo/source/_posts中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//或者新建文章 默认放置在hexo/source/_posts中</span></span><br><span class="line">hexo <span class="keyword">new</span> <span class="string">"test"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Next主题新建页面</span></span><br><span class="line">hexo <span class="keyword">new</span> page <span class="string">"分类"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//照样在hexo文件夹下执行</span></span><br><span class="line"></span><br><span class="line">hexo d -g</span><br></pre></td></tr></table></figure></li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://help.github.com/cn/github/working-with-github-pages/about-github-pages" target="_blank" rel="noopener">GitHub Pages官方说明文档</a></li><li><a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">Hexo官方文档</a></li><li><a href="https://blog.csdn.net/qq_36759224/article/details/82121420#font_colorFF000_font_12" target="_blank" rel="noopener">使用 GitHub Pages和Hexo搭建自己的独立博客</a></li></ul>]]></content>
    
    <summary type="html">
    
      基于Hexo与GitHub Pages搭建独立博客
    
    </summary>
    
    
      <category term="教程" scheme="http://yoursite.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="Hexo" scheme="http://yoursite.com/tags/Hexo/"/>
    
      <category term="GitHub Pages" scheme="http://yoursite.com/tags/GitHub-Pages/"/>
    
  </entry>
  
  <entry>
    <title>博客伊始</title>
    <link href="http://yoursite.com/2019/09/20/%E5%8D%9A%E5%AE%A2%E4%BC%8A%E5%A7%8B/"/>
    <id>http://yoursite.com/2019/09/20/%E5%8D%9A%E5%AE%A2%E4%BC%8A%E5%A7%8B/</id>
    <published>2019-09-20T15:29:47.000Z</published>
    <updated>2020-04-29T09:05:18.417Z</updated>
    
    <content type="html"><![CDATA[<h2 id="博客伊始"><a href="#博客伊始" class="headerlink" title="博客伊始"></a>博客伊始</h2><p align="right"><font color="grey">作者：冬结</font></p><blockquote><p>写在前面：<br>偶然看到Hexo模板的博客，观感不错，加上前辈也搭过，就试试以这种相对简单的形式搭建起来玩。一方面简单学习以现有框架搭建专属博客的“技术”，另一方面也能有个容器装一点自己的笔记，尽管可能比较少，可能并不安全，聊胜于无。</p></blockquote><h3 id="兴趣"><a href="#兴趣" class="headerlink" title="兴趣"></a>兴趣</h3><p>我的兴趣，很难讲。佛系（可能）心态的人在平静生活中貌似对所有的事不放心上，所以，电影可以不看、单车可以不骑、乒乓球可以不打、书可以不阅读、随笔可以不写、游戏可以不玩。自我认知是一个漫长的过程，从浪漫理想主义到实用现实主义，说到底也划不清界限。妥协的做法是就此作罢，不去深究，也就能将困惑搁置一旁。况且说辞也是一大把，比如复杂的个体就能说服我自己。一贯的自我否定，也可以说深究一法至少能够审视自我更加全面深刻，更加接近真实。否定之否定，打住！</p><p>接着说兴趣。从某种维度上讲，兴趣带来愉悦、专注与充实感。</p><p>这样说来，好的电影是我的兴趣，带给我专注与思考。看过的电影也不少，影评却没尝试过一篇。电影没有带给我充实感，但我并不认为它在浪费时间。娱乐的底质，依旧能够容纳艺术与生活。尽管总能从这种媒介中看到不真实，生活的经验依然鲜活。现在的我能以相对包容的眼光对待现实的种种“怪象”，大抵与之有所关联。</p><p>骑单车溜达也算得上。单车是真的单车，单人单骑，随便找个目标，也就慢慢悠悠的去。骑行就不能描述我的方式了，老老实实地去骑单车溜达。某次，什么背景的现在全无记忆，只是感到沉闷的低落，简直到不能忍受的地步，然后就溜达着去后海那边。也许逛胡同，也许没有。至于能否缓解我的状态，我也记不得。只是到那种状态，我能想到这种方式去排解，多少也算是一种认同吧。</p><p>至于随笔（恰当称谓？），也能算是我的兴趣。偶尔写写东西，偶尔是真的偶偶尔。我从写文字当中获取的安静、专注、充实感显而易见，而文字大多都是当时的情绪与想法，可能脱胎于日记，但也将一些真实到黑暗的思考隐藏起来，多少能见光。不知道将自我产出的文字视若珍宝算不算病态，但我的确珍视，在我眼里这些文字能真切表示一种状态，这一刻我就是美化的真实的。至于这种方式何以占据重要的位置，大概因为内心戏丰富如我，不善表达情绪，多少是关掉大门开几扇窗。</p><p>其他能说的，读书、乒乓和游戏，目前的程度都还比较浅。曾经都热过一阵的行为，慢慢沉寂下来也沾上了尘土。所谓的我的兴趣，没得一项算是个人特长。骑车只是休闲，电影只是娱乐，随笔也只是偶尔的文艺，但是至少这些，能够成为生活的调剂，是能够令我感到舒适的生活方式。</p><h3 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h3><p>整理些技术向的学习内容，也多少要往这博客里边搁，况且，这本就是搭建这玩意的初衷。尽管不太喜欢用“工作”一词，但还是必须得慢慢习惯的。</p><p>求学时期拥有很好的学习环境，这段时间也就余下几年，两者都不得不承认。实验室的一些开发工作，还有自己看过的、学过的、实践过的一些内容，选择性的往这个博客里边搁。尽量减少一些空洞的文字（多一些图），减少随处可见的教程，多一点自己的总结，就是描述不规范，甚至有错误也无关紧要。他人的是他人的，转化为自己的才是自己的。尽管这些话可有可无，也就这样摆在这里了。</p><p>至于具体的工作内容，也没法细说。只是一段时间过去，觉得稍微闲下来时，慢悠悠写一点总结，多少能够察觉出自己在缓慢的生长，就很开心了。至于成长的快与慢，也不多去琢磨。吃饭慢，跑步慢，性子慢……真要快节奏起来，真就为难我“胖虎”了！</p><h3 id="成长"><a href="#成长" class="headerlink" title="成长"></a>成长</h3><p>现在过多的想法与计划一如既往地空白，只是希望每天有点进步，慢慢生长吧。</p><p>趁现在还有点记忆，罗列下自初中以来每个阶段自我希求的关键词。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">改变 ：白墙上丑陋的浓墨毛笔字，墨迹未干尚不回望，小屋也拆了，斑驳的往事不能再找回。</span><br><span class="line">掌控 ：年少时总希望能够决定自己的命运，可是连早睡早起也没有做到。</span><br><span class="line">自由 ：那四年时光，持续性潇洒，间歇性焦虑。觉睡得很饱，书读得也少。向自己一样平平淡淡。</span><br><span class="line">成长 ：有的人每天跑步，有的人会慢慢散步。蜗牛和火箭，都在自以为的前进。</span><br></pre></td></tr></table></figure><h3 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h3><p>今天是2019年9月20日，算是一个开始吧！</p><p><img src="https://cdn.jsdelivr.net/gh/biggfish3147/pics/blog/xingkong.jpeg" alt="星空"></p>]]></content>
    
    <summary type="html">
    
      君不见，黄河之水天上来，奔流到海不复回
    
    </summary>
    
    
      <category term="随笔" scheme="http://yoursite.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="随笔" scheme="http://yoursite.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
</feed>
